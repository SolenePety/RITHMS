[{"path":[]},{"path":"/CODE_OF_CONDUCT.html","id":"our-pledge","dir":"","previous_headings":"","what":"Our Pledge","title":"Contributor Covenant Code of Conduct","text":"members, contributors, leaders pledge make participation community harassment-free experience everyone, regardless age, body size, visible invisible disability, ethnicity, sex characteristics, gender identity expression, level experience, education, socio-economic status, nationality, personal appearance, race, caste, color, religion, sexual identity orientation. pledge act interact ways contribute open, welcoming, diverse, inclusive, healthy community.","code":""},{"path":"/CODE_OF_CONDUCT.html","id":"our-standards","dir":"","previous_headings":"","what":"Our Standards","title":"Contributor Covenant Code of Conduct","text":"Examples behavior contributes positive environment community include: Demonstrating empathy kindness toward people respectful differing opinions, viewpoints, experiences Giving gracefully accepting constructive feedback Accepting responsibility apologizing affected mistakes, learning experience Focusing best just us individuals, overall community Examples unacceptable behavior include: use sexualized language imagery, sexual attention advances kind Trolling, insulting derogatory comments, personal political attacks Public private harassment Publishing others’ private information, physical email address, without explicit permission conduct reasonably considered inappropriate professional setting","code":""},{"path":"/CODE_OF_CONDUCT.html","id":"enforcement-responsibilities","dir":"","previous_headings":"","what":"Enforcement Responsibilities","title":"Contributor Covenant Code of Conduct","text":"Community leaders responsible clarifying enforcing standards acceptable behavior take appropriate fair corrective action response behavior deem inappropriate, threatening, offensive, harmful. Community leaders right responsibility remove, edit, reject comments, commits, code, wiki edits, issues, contributions aligned Code Conduct, communicate reasons moderation decisions appropriate.","code":""},{"path":"/CODE_OF_CONDUCT.html","id":"scope","dir":"","previous_headings":"","what":"Scope","title":"Contributor Covenant Code of Conduct","text":"Code Conduct applies within community spaces, also applies individual officially representing community public spaces. Examples representing community include using official e-mail address, posting via official social media account, acting appointed representative online offline event.","code":""},{"path":"/CODE_OF_CONDUCT.html","id":"enforcement","dir":"","previous_headings":"","what":"Enforcement","title":"Contributor Covenant Code of Conduct","text":"Instances abusive, harassing, otherwise unacceptable behavior may reported community leaders responsible enforcement contact@fake.com. complaints reviewed investigated promptly fairly. community leaders obligated respect privacy security reporter incident.","code":""},{"path":"/CODE_OF_CONDUCT.html","id":"enforcement-guidelines","dir":"","previous_headings":"","what":"Enforcement Guidelines","title":"Contributor Covenant Code of Conduct","text":"Community leaders follow Community Impact Guidelines determining consequences action deem violation Code Conduct:","code":""},{"path":"/CODE_OF_CONDUCT.html","id":"id_1-correction","dir":"","previous_headings":"Enforcement Guidelines","what":"1. Correction","title":"Contributor Covenant Code of Conduct","text":"Community Impact: Use inappropriate language behavior deemed unprofessional unwelcome community. Consequence: private, written warning community leaders, providing clarity around nature violation explanation behavior inappropriate. public apology may requested.","code":""},{"path":"/CODE_OF_CONDUCT.html","id":"id_2-warning","dir":"","previous_headings":"Enforcement Guidelines","what":"2. Warning","title":"Contributor Covenant Code of Conduct","text":"Community Impact: violation single incident series actions. Consequence: warning consequences continued behavior. interaction people involved, including unsolicited interaction enforcing Code Conduct, specified period time. includes avoiding interactions community spaces well external channels like social media. Violating terms may lead temporary permanent ban.","code":""},{"path":"/CODE_OF_CONDUCT.html","id":"id_3-temporary-ban","dir":"","previous_headings":"Enforcement Guidelines","what":"3. Temporary Ban","title":"Contributor Covenant Code of Conduct","text":"Community Impact: serious violation community standards, including sustained inappropriate behavior. Consequence: temporary ban sort interaction public communication community specified period time. public private interaction people involved, including unsolicited interaction enforcing Code Conduct, allowed period. Violating terms may lead permanent ban.","code":""},{"path":"/CODE_OF_CONDUCT.html","id":"id_4-permanent-ban","dir":"","previous_headings":"Enforcement Guidelines","what":"4. Permanent Ban","title":"Contributor Covenant Code of Conduct","text":"Community Impact: Demonstrating pattern violation community standards, including sustained inappropriate behavior, harassment individual, aggression toward disparagement classes individuals. Consequence: permanent ban sort public interaction within community.","code":""},{"path":"/CODE_OF_CONDUCT.html","id":"attribution","dir":"","previous_headings":"","what":"Attribution","title":"Contributor Covenant Code of Conduct","text":"Code Conduct adapted Contributor Covenant, version 2.1, available https://www.contributor-covenant.org/version/2/1/code_of_conduct.html. Community Impact Guidelines inspired [Mozilla’s code conduct enforcement ladder][https://github.com/mozilla/inclusion]. answers common questions code conduct, see FAQ https://www.contributor-covenant.org/faq. Translations available https://www.contributor-covenant.org/translations.","code":""},{"path":"/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2024 John Doe Permission hereby granted, free charge, person obtaining copy software associated documentation files (“Software”), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED “”, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"/articles/generate-figures.html","id":"load-data","dir":"Articles","previous_headings":"","what":"Load data","title":"Generate figures","text":"data matrix loaded count matrix taxa (columns) across individuals (rows). toy dataset, subset Déru et al. 2020, 1845 species 780 individuals coming conventional diet. Genotypes encoded 0,1,2 reachable thanks “population” attribute.","code":"datafile <- system.file(\"DeruPop.rds\", package = \"RITHMS\") founder_object <- readRDS(datafile)  founder_object[1:5,1:5] #>   OTU1 OTU2 OTU6793 OTU3 OTU4 #> 1   30  593       4  630  414 #> 2  254  275      62 1131  446 #> 3  181  487     164 1472  656 #> 4  469  665      45  640  328 #> 5  771  519      21  758  347 #MoBPS population structure, use get.geno() and generation index to extract genotypes genotypes <- attr(founder_object, \"population\") %>%   get.geno(gen=1)  genotypes[1:5,1:5] #>      M1_1 M2_1 M3_1 M4_1 M5_1 #> SNP1    2    2    1    1    2 #> SNP2    1    1    1    1    1 #> SNP3    2    2    2    2    2 #> SNP4    2    2    2    2    2 #> SNP5    2    2    1    1    2"},{"path":"/articles/generate-figures.html","id":"simulation-reflects-structure-of-microbiome","dir":"Articles","previous_headings":"","what":"Simulation reflects structure of microbiome","title":"Generate figures","text":"section matches code Figure 3 paper.","code":""},{"path":"/articles/generate-figures.html","id":"produce-intra--and-inter-cluster-anticorrelations","dir":"Articles","previous_headings":"Simulation reflects structure of microbiome","what":"Produce intra- and inter-cluster (anti)correlations","title":"Generate figures","text":"β\\beta matrix, values overlapping QTL, ’re able induce correlations taxa. example, 4% taxa genetic control. pairwise correlation matrix taxa abundances represented . Taxa sorted based cluster belong . elements ’re able call holo_simu(). β\\beta matrix reachable metadata holo_simu() output. ’re able build Heatmap using ComplexHeatmap","code":"taxa_assign_g_small <- assign_taxa(founder_object,                                     taxa_g = 0.04)  # Output is the assignation of each taxa to a cluster, 0 corresponds to taxa that are not under genetic control taxa_assign_g_small[taxa_assign_g_small !=0 ] #>  [1] 1 1 1 2 1 1 2 1 3 4 3 4 3 2 2 2 4 3 2 5 2 2 2 4 3 3 2 3 4 3 3 1 6 6 1 6 4 4 #> [39] 6 1 5 5 1 5 4 4 1 5 3 3 4 2 6 4 6 5 5 4 6 6 6 2 3 5 1 5 5 5 5 5 6 6 4 4 4 5 #> [77] 4 3 6 #> Levels: 0 1 2 3 4 5 6 noise = 0.6 #noise of the microbiome effect.size = 0.3 #genetic effect size lambda = 0.5 #same weight for vertical and horizontal transmission dir = T #dirichlet sampling for ambient microbiome  generations_simu <- holo_simu(h2 = 0.25, #direct heritability                               b2 = 0.25, #microbiability                               founder_object = founder_object,                               n_clust = taxa_assign_g_small,                               n_ind = 500, #per generation                               verbose = F,                                noise.microbiome = noise,                               effect.size = effect.size,                               lambda = lambda,                               dir = dir,                               selection = F, #30% males and females sampled for next generation                               seed = 333) #Correlation intra-cluster for cluster under genetic control beta <- generations_simu$metadata$Beta_matrix[taxa_assign_g_small != 0,] cor_matrix <- cor(t(beta)) taxa_order <- taxa_assign_g_small[taxa_assign_g_small != 0] %>% order() cor_matrix <- cor_matrix[taxa_order,taxa_order] pal <- colorRampPalette(RColorBrewer::brewer.pal(5,\"Set1\"))(length(taxa_assign_g_small[taxa_assign_g_small != 0] %>% unique())) clus_col <- structure(pal, names = taxa_assign_g_small[taxa_assign_g_small != 0] %>% unique() %>% as.vector())  leftAnn = rowAnnotation(clust = taxa_assign_g_small[taxa_assign_g_small != 0] %>% sort(),                         col = list(clust = clus_col),                         show_annotation_name = F,                         annotation_legend_param = list(clust = list(title = \"Cluster ID\",title_gp = gpar(fontsize = 5, fontface = \"bold\"), labels_gp = gpar(fontsize = 5, fontface = 'bold')))) colAnn = HeatmapAnnotation(clust = taxa_assign_g_small[taxa_assign_g_small != 0] %>% sort(),                         col = list(clust = clus_col),                         show_annotation_name = F,                         show_legend = FALSE)  col_fun = colorRamp2(c(min(cor_matrix), 0, max(cor_matrix)), c(\"blue\", \"white\", \"red\"))  p1 <- grid.grabExpr(draw(Heatmap(cor_matrix,          cluster_rows = F,          cluster_columns = F,          show_row_names = F,          show_column_names = F,         left_annotation = leftAnn,         top_annotation = colAnn,         #col = col_fun,         heatmap_legend_param = list(title = \"Correlation\", title_gp = gpar(fontsize = 5, fontface = \"bold\"), labels_gp = gpar(fontsize = 5, fontface = 'bold')))))  plot_grid(p1)"},{"path":"/articles/generate-figures.html","id":"modulate-relative-importance-of-vertical-and-horizontal-transmission","dir":"Articles","previous_headings":"Simulation reflects structure of microbiome","what":"Modulate relative importance of vertical and horizontal transmission","title":"Generate figures","text":"composition microbiota individuals given equation : λ𝐌d()(t−1)+(1−λ)𝐌a()(t)\\lambda \\boldsymbol{M}^{(t-1)}_{d()} + (1 - \\lambda) \\boldsymbol{M}^{(t)}_{()}. Given , λ=0\\lambda = 0 corresponds vertical transmission. ’re looking correlations offspring α-diversity (G2) mother (purple), father (orange) ambient microbiota (green) increasing values λ. ’ve used loop iterations different seeds λ\\lambda values. code optimized using purrr package. useful informations simulations microbiomes, pedigree ambient microbiome extracted generation. ’re focusing G2 .","code":"set.seed(484) #Change n_it to increase the accuracy of the function, n_it = 10 used in the article n_it = 1 seed_value <- sample(c(100:9999),n_it)  taxa_assign_g <- assign_taxa(founder_object) noise = 0.1 effect.size = 0.1 center_bg = T dir = T lambda = c(0,0.5,1)  #Boxplot lambda vs diversity correlation with offspring   cor_gen_table <- data.frame()   for(s in seed_value){     print(glue(\"Seed : {s}\"))     for(l in lambda){       print(glue(\"Lambda : {l}\"))       generations_simu <- holo_simu(h2 = 0.25,                                     b2 = 0.25,                                     founder_object = founder_object,                                     n_clust = taxa_assign_g,                                     n_ind = 500,                                     verbose = F,                                     noise.microbiome = noise,                                     effect.size = effect.size,                                     lambda = l,                                     dir = dir,                                     selection = F,                                     seed = s)        current_div <- generations_simu$G2$microbiome %>% richness_from_abundances_gen()       previous_s_div <- sapply(generations_simu$G2$pedigree[,\"father\"],function(x){generations_simu$G1$microbiome[,x]}) %>% richness_from_abundances_gen()       previous_d_div <- sapply(generations_simu$G2$pedigree[,\"mother\"],function(x){generations_simu$G1$microbiome[,x]}) %>% richness_from_abundances_gen()       ambient_div <- generations_simu$G2$mean_microbiome %>% richness_from_abundances_gen()       cor_gen_table <- rbind(cor_gen_table,                            cbind(l,                                  cor(current_div$Shannon,previous_d_div$Shannon),                                  cor(current_div$Shannon,previous_s_div$Shannon),                                  cor(current_div$Shannon,ambient_div$Shannon)))     }   }   colnames(cor_gen_table) <- c(\"lambda\",\"Mother\",\"Father\",\"Ambient\")   long_cor_gen <- cor_gen_table %>% pivot_longer(c(\"Mother\",\"Father\",\"Ambient\"),                                                  names_to = \"cor_type\",                                                  values_to = \"value\") lambda_label <- cbind(x = c(0,0.5,1),                       y = c(0.8,0.2,0.8),                       label = c(\"Ambient\",\"Father\",\"Mother\")) %>% as.data.frame() lambda_label$y <- as.numeric(lambda_label$y)  p3 <- long_cor_gen %>% summarise(value = mean(value), .by = c(lambda, cor_type)) |> ggplot(aes(x=as.factor(lambda),y=value,col=cor_type, group = cor_type)) +   geom_line() +   geom_point( alpha=0.8)  +   geom_text_repel(data = lambda_label,                   aes(x = x, y = y, label = label, color = label, group = NULL),         direction = \"y\",         show.legend = FALSE) +   theme(panel.background = element_rect(fill=\"white\"),         panel.grid.major = element_line(colour=\"#e3e3e3\"),         panel.grid.minor = element_line(colour=\"#e9e9e9\"),         axis.title = element_text(size = 8),         axis.text = element_text(size=7),         plot.title = element_text(size=12),         legend.key.size = unit(0.25, 'cm'), #change legend key size         legend.title = element_text(size=7), #change legend title font size         legend.text = element_text(size=7),         legend.position = \"none\") +   ylab(\"Correlation value\") +   xlab(\"Lambda\") +   labs(col = \"Parents\") +   guides(shape = \"none\") +   ylim(-0.2,1) +   scale_y_continuous(     breaks = seq(0,1,0.25),     labels = seq(0,1,0.25)   ) +   scale_color_brewer(palette = \"Dark2\")  p3"},{"path":"/articles/generate-figures.html","id":"achieve-a-target-distribution-of-taxa-heritabilities","dir":"Articles","previous_headings":"Simulation reflects structure of microbiome","what":"Achieve a target distribution of taxa heritabilities","title":"Generate figures","text":"function calibrate_gen_effect() intended guide user choosing appropriate effect size achieve target distribution taxa heritabilities. Build-plots function ’ve used output function order make density plot distribution taxa heritability increasing genetic effect sizes (σβ×QTLo\\sigma_{\\beta}\\times\\sqrt{\\text{QTL}_\\text{o}}), shown curve.","code":"out_data <- gen_effect_calibration(founder_object = founder_object,                                    taxa_assign_g = taxa_assign_g,                                    correlation = 0.5,                                    effect.size = c(0.3,0.6,1),                                    plot = F) # Calculate density peaks density_peaks <- out_data %>%   group_by(effect.size) %>%   summarise(     peak = density(Heritability)$y[which.max(density(Heritability)$y)],     peak_x = density(Heritability)$x[which.max(density(Heritability)$y)]   )    p2 <- out_data %>% ggplot(aes(x=Heritability,fill=as.factor(effect.size), label = as.factor(effect.size))) +       geom_density(alpha=0.8, color = NA)+       geom_text_repel(         data = density_peaks,         aes(x = peak_x, y = peak, label = effect.size, color = as.factor(effect.size)),         nudge_x = 0.02,         nudge_y = 0.3,         direction = \"y\",         show.legend = FALSE) +       labs(x = \"Taxa heritability\",            y = \"Density\",            fill = \"Genetic effect size\")+       theme(panel.background = element_rect(fill=\"white\"),             panel.grid.major = element_line(colour=\"#e3e3e3\"),             panel.grid.minor = element_line(colour=\"#e9e9e9\"),             axis.title = element_text(size = 8),             axis.text = element_text(size=7),             plot.title = element_text(size=7),             legend.position = \"none\") +     scale_fill_manual(values = c(\"#00AFBB\", \"#E7B800\", \"#FC4E07\")) +     scale_color_manual(values = c(\"#00AFBB\", \"#E7B800\", \"#FC4E07\"))  p2"},{"path":"/articles/generate-figures.html","id":"alpha-diversity-remains-stable-across-generations","dir":"Articles","previous_headings":"Simulation reflects structure of microbiome","what":"Alpha-diversity remains stable across generations","title":"Generate figures","text":"neutral framework, without selection environmental effect, expect α\\alpha-diversity stable across generations. holo_simu() output, relative abundances taxa, α\\alpha-diversity indexes thanks multinomial sampling richness_from_abundances_gen() function.","code":"h2 = 0.25 b2 = 0.25 generations_simu <- holo_simu(h2 = h2,                               b2 = b2,                               founder_object = founder_object,                               n_clust = taxa_assign_g,                               n_ind = 500,                               verbose = F,                               noise.microbiome = noise,                               effect.size = effect.size,                               lambda = 0.5,                               dir = dir,                               selection = F,                               seed = 8082) diversities_microbiomes <- generations_simu[-1] %>% map(get_microbiomes) %>% map(richness_from_abundances_gen) |> bind_rows(.id = \"Generation\")   p4 <- ggplot(diversities_microbiomes,aes(x=Shannon,y=Generation,fill=Generation)) +         geom_density_ridges(alpha=0.8) +          theme(legend.position = \"none\",               panel.background = element_rect(fill=\"white\"),               panel.grid.major = element_line(colour=\"#e3e3e3\"),               panel.grid.minor = element_line(colour=\"#e9e9e9\"),               axis.title = element_text(size = 8),               axis.text = element_text(size=7),               plot.title = element_text(size=12),               aspect.ratio = 1.5)+   scale_fill_manual(values = rev(greens_pal))    p4 ggsave(\"../man/figures/ridges_shannon.png\", p4, width = 9, height = 6)"},{"path":"/articles/generate-figures.html","id":"introduction-of-transient-perturbations-of-the-microbiota","dir":"Articles","previous_headings":"","what":"Introduction of transient perturbations of the microbiota","title":"Generate figures","text":"breeding selection programs, essential account fixed environmental effects, given strong role modulating individual’s phenotype. therefore important verify simulated transgenerational hologenomic data can correctly integrate factors variety plausible scenarios, short-term treatments long-term diet effects. build modulation, user build outside main function θX\\theta X product choose precisely values effect size given environmental effect. Dimensions product match founder_object ones. evaluate simulation part ’ve computed multidimensional scaling (MDS) microbial abundance data using Bray-Curtis distances ridges plot Shannon index values. section matches code Figure 4 paper.","code":""},{"path":"/articles/generate-figures.html","id":"sporadic-environmental-effect","dir":"Articles","previous_headings":"Introduction of transient perturbations of the microbiota","what":"Sporadic environmental effect","title":"Generate figures","text":"Half individuals G1 subject sporadic antibiotic treatment affects taxa.","code":"#Construction of environmental effect before simulating the population h2 = 0.25 b2 = 0.25 noise = 0.6 effect.size = 0.3 dir= T n_ind = 500 lambda = 0.5  set.seed(42) antibio <- rep(0, n_ind) antibio_ind <- sample(1:n_ind, 250) #selecting index of individuals antibio[antibio_ind] <- 1  X <- matrix(antibio, ncol = n_ind, nrow = 1)  theta <- rnorm(ncol(founder_object),mean = 0, sd = 5) #sampling strong antibiotics effect theta <- ifelse(theta > 0, -theta, theta) %>% matrix(ncol = 1, nrow = ncol(founder_object)) #only negative values for all taxa  thetaX <- theta %*% X generations_simu_env <- holo_simu(h2 = h2,                                   b2 = b2,                                   founder_object = founder_object,                                   n_clust = taxa_assign_g,                                   n_ind = n_ind,                                   verbose = F,                                   noise.microbiome = noise,                                   effect.size = effect.size,                                   lambda = lambda,                                   dir = dir,                                   selection = F,                                   seed = 30,                                   thetaX = thetaX,                                   env_gen = c(T,F,F,F,F)) #on the five generations asked, we apply thetaX only on G1, not considering G0"},{"path":"/articles/generate-figures.html","id":"diversity-on-antibiotic-effect","dir":"Articles","previous_headings":"Introduction of transient perturbations of the microbiota > Sporadic environmental effect","what":"Diversity on antibiotic effect","title":"Generate figures","text":"Call get_microbiomes() richness_from_abundances_gen() extract useful metrics.","code":"diversities_microbiomes <- generations_simu_env[-1] %>% map(get_microbiomes) %>% map(richness_from_abundances_gen) |> bind_rows(.id = \"Generation\")    p1 <- diversities_microbiomes %>% filter(!Generation %in% c(\"G4\",\"G5\")) %>%     ggplot(aes(x=Shannon,y=Generation,fill=Generation)) +     geom_density_ridges(alpha=0.8) +      theme(legend.position = \"none\",           panel.background = element_rect(fill=\"white\"),           panel.grid.major = element_line(colour=\"#e3e3e3\"),           panel.grid.minor = element_line(colour=\"#e9e9e9\"),           axis.title = element_text(size = 8),           axis.text = element_text(size=7),           plot.title = element_text(size=12),           aspect.ratio = 1.5)+     scale_fill_manual(values = rev(greens_pal)[1:4])      p1"},{"path":"/articles/generate-figures.html","id":"mds-on-antibiotic-effect","dir":"Articles","previous_headings":"Introduction of transient perturbations of the microbiota > Sporadic environmental effect","what":"MDS on antibiotic effect","title":"Generate figures","text":"Call vegan package compute Bray Curtis distance matrix. Call phyloseq package manipulate efficiently compute MDS ordinate() function.","code":"microbiomes_all <- generations_simu_env[c(2,3,4,5)] %>% map(get_microbiomes, transpose = T, CLR = F) |> bind_rows(.id = \"Generation\")                            antibio_vec <- rep(0, nrow(microbiomes_all)) id_antibio_ind <- rownames(microbiomes_all)[which(microbiomes_all$Generation == \"G1\")] %in% colnames((generations_simu_env$G1$microbiome))[which(X != 0)] antibio_vec[which(microbiomes_all$Generation == \"G1\")[id_antibio_ind]] <- 1 metadata <- cbind(Generation = microbiomes_all$Generation, ID = rownames(microbiomes_all), antibio = antibio_vec) |> as.data.frame() rownames(metadata) <- metadata$ID dist_mat <- vegan::vegdist(x = microbiomes_all[-1],                  method = \"bray\") physeq <- phyloseq(   otu_table(t(microbiomes_all[,-1]), taxa_are_rows = TRUE),   sample_data(metadata))  ord <- ordinate(physeq, method = \"MDS\", distance = dist_mat)  DF <- plot_ordination(physeq, ord, justDF = T) p2 <- ggplot(data = DF, aes(x=DF[,1], y=DF[,2], color = antibio, shape=antibio)) +      labs(x = \"Axis 1\",          y = \"Axis 2\") +   geom_point(alpha = 0.8) +    theme(panel.background = element_rect(fill=\"white\"),             panel.grid.major = element_line(colour=\"#e3e3e3\"),             panel.grid.minor = element_line(colour=\"#e9e9e9\"),             axis.title = element_text(size = 8),             axis.text = element_text(size=7),             plot.title = element_text(size=7),             legend.key.size = unit(0.25, 'cm'), #change legend key size             legend.title = element_text(size=7), #change legend title font size             legend.text = element_text(size=7),             strip.text = element_text(color = \"white\", face = \"bold\")         ) +   facet_wrap2(~Generation, nrow = 2, ncol = 2, strip = strip_themed(background_x = elem_list_rect(fill = rev(greens_pal)[1:4])))  p2"},{"path":"/articles/generate-figures.html","id":"sustained-environmental-effet","dir":"Articles","previous_headings":"Introduction of transient perturbations of the microbiota","what":"Sustained environmental effet","title":"Generate figures","text":"Starting G1, half individuals generation (blue triangles) subject diet favoring two clusters taxa.","code":"h2 = 0.25 b2 = 0.25 noise = 0.6 effect.size = 0.3 dir= T center_bg = T n_ind = 500 lambda = 0.5  set.seed(56) # Xi <- small portions of individuals diet <- rep(0, n_ind) diet_ind <- sample(1:n_ind, 250) diet[diet_ind] <- 1  X <- matrix(diet, ncol = n_ind, nrow = 1)  theta <- rep(0, length(taxa_assign_g)) cluster_diet <- table(taxa_assign_g)[table(taxa_assign_g) > 10 & table(taxa_assign_g) < 30] %>% sample(3) %>% names() %>% as.numeric() #sample of clusters modulated by diet theta[taxa_assign_g %in% cluster_diet] <- rnorm(sum(taxa_assign_g %in% cluster_diet ),mean = 0, sd = 2) theta <- ifelse(theta < 0, -theta, theta) %>% matrix(ncol = 1, nrow = length(taxa_assign_g))#Only positive values for all taxa  thetaX <- theta %*% X generations_simu_env <- holo_simu(h2 = h2,                               b2 = b2,                               founder_object = founder_object,                               n_clust = taxa_assign_g,                               n_ind = n_ind,                               verbose = F,                               noise.microbiome = noise,                               effect.size = effect.size,                               lambda = lambda,                               dir = dir,                               selection = F,                               seed = 3042,                               thetaX = thetaX,                               env_gen = c(T,T,T,T,T)) #Applied on all generations"},{"path":"/articles/generate-figures.html","id":"diversity-on-antibiotic-effect-1","dir":"Articles","previous_headings":"Introduction of transient perturbations of the microbiota > Sustained environmental effet","what":"Diversity on antibiotic effect","title":"Generate figures","text":"","code":"diversities_microbiomes <- generations_simu_env[c(2,3,4,5)] %>% map(get_microbiomes) %>% map(richness_from_abundances_gen) |> bind_rows(.id = \"Generation\")    p4 <- ggplot(diversities_microbiomes,aes(x=Shannon,y=Generation,fill=Generation)) +         geom_density_ridges(alpha=0.8) +          theme(legend.position = \"none\",               panel.background = element_rect(fill=\"white\"),               panel.grid.major = element_line(colour=\"#e3e3e3\"),               panel.grid.minor = element_line(colour=\"#e9e9e9\"),               axis.title = element_text(size = 8),               axis.text = element_text(size=7),               plot.title = element_text(size=12),               aspect.ratio = 1.5)+         scale_fill_manual(values = rev(greens_pal)[1:4]) p4"},{"path":"/articles/generate-figures.html","id":"mds-on-antibiotic-effect-1","dir":"Articles","previous_headings":"Introduction of transient perturbations of the microbiota > Sustained environmental effet","what":"MDS on antibiotic effect","title":"Generate figures","text":"","code":"#Post-processing of the data microbiomes_all <- generations_simu_env[c(2,3,4,5)] %>% map(get_microbiomes, transpose = T, CLR = F) |> bind_rows(.id = \"Generation\")  diet_vec <- rep(0, nrow(microbiomes_all)) diet_vec[which(microbiomes_all$Generation == \"G1\")[diet_ind]] <- 1 diet_vec[which(microbiomes_all$Generation == \"G2\")[diet_ind]] <- 1 diet_vec[which(microbiomes_all$Generation == \"G3\")[diet_ind]] <- 1 diet_vec[which(microbiomes_all$Generation == \"G4\")[diet_ind]] <- 1 diet_vec[which(microbiomes_all$Generation == \"G5\")[diet_ind]] <- 1  metadata <- cbind(Generation = microbiomes_all$Generation, ID = rownames(microbiomes_all), diet = diet_vec) |> as.data.frame() rownames(metadata) <- metadata$ID dist_mat <- vegan::vegdist(x = microbiomes_all[-1],                  method = \"bray\") physeq <- phyloseq(   otu_table(t(microbiomes_all[,-1]), taxa_are_rows = TRUE),   sample_data(metadata))  ord <- ordinate(physeq, method = \"MDS\", distance = dist_mat) DF <- plot_ordination(physeq, ord, justDF = T) p3 <- ggplot(data = DF, aes(x=DF[,1], y=DF[,2], color = diet, shape=diet)) +      labs(x = \"Axis 1\",          y = \"Axis 2\") +   geom_point(alpha = 0.8) +    theme(panel.background = element_rect(fill=\"white\"),             panel.grid.major = element_line(colour=\"#e3e3e3\"),             panel.grid.minor = element_line(colour=\"#e9e9e9\"),             axis.title = element_text(size = 8),             axis.text = element_text(size=7),             plot.title = element_text(size=7),             legend.key.size = unit(0.25, 'cm'), #change legend key size             legend.title = element_text(size=7), #change legend title font size             legend.text = element_text(size=7),             strip.text = element_text(color = \"white\", face = \"bold\")) +#change legend text font size)    facet_wrap2(~Generation, nrow = 2, ncol = 2, strip = strip_themed(background_x = elem_list_rect(fill = rev(greens_pal)[1:4]))) +   scale_fill_manual(values = rev(greens_pal)[1:4]) p3"},{"path":"/articles/generate-figures.html","id":"fine-selection-of-direct-heritability-microbiability-and-selection-schemes","dir":"Articles","previous_headings":"","what":"Fine selection of direct heritability, microbiability and selection schemes","title":"Generate figures","text":"absence selection, want verify target values reached maintained across generations observe trends phenotypic improvement function four different selection strategies. computation plots section performed time, barplot subset facet grid. section matches code Figure 5 paper.","code":""},{"path":"/articles/generate-figures.html","id":"target-values-of-direct-heritability-and-microbiability-are-reached-and-maintained","dir":"Articles","previous_headings":"Fine selection of direct heritability, microbiability and selection schemes","what":"Target values of direct heritability and microbiability are reached and maintained","title":"Generate figures","text":"want parallelize code, use plan(multisession).","code":"# n_it = 50 was used to generate the figures of the article n_it = 1 set.seed(42) vec_seed <- sample(100:10000,n_it) noise = 0.6 effect.size = 0.3 lambda = 0.1 dir = T    #For the exemple, not all values were computed, you can uncomment all the lines to obtain the complete figure. params_df_it <- tibble::tribble(   ~h2,  ~b2, #  0.05, 0.05, #  0.25, 0.05, #  0.4,  0.05,  # 0.05, 0.25,   0.25, 0.25,   0.4,  0.25, #  0.05, 0.4,  0.25, 0.4,   0.4,  0.4   ) |> crossing(tibble(`Selection Type` = c(\"GB\", \"G\", \"B\", \"None\")),tibble(seed = vec_seed)) |>    mutate(sim_ID = row_number(), .before = \"h2\") params_df <- tibble::tribble(   ~h2,  ~b2,  # 0.05, 0.05,  # 0.25, 0.05, #  0.4,  0.05,  # 0.05, 0.25,   0.25, 0.25,   0.4,  0.25, #  0.05, 0.4,   0.25, 0.4,   0.4,  0.4 ) |>    crossing(tibble(`Selection Type` = c(\"GB\", \"G\", \"B\", \"Random\"))) |>    mutate(sim_ID = row_number(), .before = \"h2\") run_simulation <- function(i, it) {   start_time_it <- Sys.time()    ram_result <- peakRAM({   taxa_assign_g <- assign_taxa(founder_object)    generations_simu <- holo_simu(     h2 = params_df$h2[i],     b2 = params_df$b2[i],     founder_object = founder_object,     n_clust = taxa_assign_g,     n_ind = 500,     verbose = FALSE,     noise.microbiome = noise,     effect.size = effect.size,     lambda = lambda,     dir = dir,     selection = if (params_df$`Selection Type`[i] == \"Random\") FALSE else TRUE,     size_selection_F = 0.3,     size_selection_M = 0.3,     selection_type = if (params_df$`Selection Type`[i] == \"Random\") NULL else params_df$`Selection Type`[i],     seed = vec_seed[it]   )   })    gc() #clean memory    phenotypes_all <- generations_simu[-1] %>% map(get_phenotypes) |> bind_rows(.id = \"Generation\")      tibble(mean_phenotypes = list(generations_simu[-1] %>%                                    map(get_mean_phenotypes)),          metric_values = list(phenotypes_all %>%                                  group_by(Generation) %>%                                  summarise(h2 = var(gq)/var(y),                                            b2 = var(gb)/var(y),                                            e2 = 1 - var(gq)/var(y) - var(gb)/var(y)))   )   } plan(sequential) results <- future_map_dfr(   seq_len(nrow(params_df)),   function(i) {     map_dfr(seq_len(n_it), ~ run_simulation(i, .x))   } ) plan(sequential) metrics_values <- results %>%    bind_cols(params_df_it) %>%    filter(h2 == 0.25,b2 == 0.25) %>% #for barplot, gather only results for h2 = b2 = 0.25   select(metric_values) %>%    unnest_wider(metric_values) %>%    unnest_longer(c(Generation,h2,b2,e2)) %>%    group_by(Generation) %>%    summarize(h2 = mean(h2), b2 = mean(b2), e2=mean(e2)) %>%    pivot_longer(cols = c(h2, b2, e2), names_to = \"Metric\", values_to = \"Value\")  metrics_values$Metric <- factor(metrics_values$Metric, levels = c(\"e2\",\"b2\",\"h2\")) colours <- setNames(c(\"#ce0104\", \"#0237AE\", \"#808080\"),                      c(\"b2\", \"h2\", \"e2\"))  p2 <- metrics_values |> ggplot(aes(x=Generation, y = Value, fill = Metric))+   geom_bar(stat = \"identity\") +    ylab(\"Value\") +   theme(panel.background = element_rect(fill=\"white\"),         panel.grid.major = element_line(colour=\"#e3e3e3\"),         panel.grid.minor = element_line(colour=\"#e9e9e9\"),         axis.title = element_text(size = 12),         axis.text = element_text(size=9),         plot.title = element_text(size=12),         axis.text.y = element_text(vjust = seq(0, 1, length.out = 5)),          legend.position = \"none\") +   geom_hline(yintercept = 0.25, col=\"white\", linetype = 2) +    annotate(\"text\", x = 3, y= 0.125, label=expression(bold(h[d]^2)), color = \"white\", size = 4) +    geom_hline(yintercept = 0.5, col=\"white\", linetype = 2) +    annotate(\"text\", x = 3, y= 0.375, label=expression(bold(b^2)), color = \"white\", size = 4) +    annotate(\"text\", x = 3, y= 0.75, label=expression(bold(e^2)), color = \"white\", size = 4) +    scale_y_continuous(expand = expansion(0, 0)) +    scale_fill_manual(values = colours) p2"},{"path":"/articles/generate-figures.html","id":"mean-phenotype-change-across-generations-according-to-selection-strategy","dir":"Articles","previous_headings":"Fine selection of direct heritability, microbiability and selection schemes","what":"Mean phenotype change across generations according to selection strategy","title":"Generate figures","text":"selection criteria : - Red line = Selection microbiota breeding values, - Blue line = Selection direct breeding values, - Purple line = Selection total breeding values, - Black line = Random selection","code":"mean_phenotypes <- results %>%    select(mean_phenotypes) %>%    bind_cols(params_df_it) %>%    unnest_wider(mean_phenotypes)  phenotypes_longer <- mean_phenotypes %>%    pivot_longer(cols = matches(\"^G\"), values_to = \"Y mean\", names_to = \"Generation\") %>%    summarise(\"Y sd\"   = sd(`Y mean`),              \"Y mean\" = mean(`Y mean`),             .by = c(`Selection Type`, Generation, h2, b2)) |>    mutate(\"Y mean\" = `Y mean` - `Y mean`[Generation == \"G0\"], .by = c(`Selection Type`, h2, b2))  phenotypes_longer$`Selection Type` <- ifelse(phenotypes_longer$`Selection Type` == \"GB\",\"TBV\", phenotypes_longer$`Selection Type`)  colours <- c(   B = \"#ce0104\",    G = \"#0237AE\",    TBV = \"#8123d9\",    None = \"black\" )  custom_labeller <- labeller(   b2 = as_labeller(function(x) paste0(\"b^2 == \", x), label_parsed),   h2 = as_labeller(function(x) paste0(\"h[d]^2 == \", x), label_parsed) )  labels <- phenotypes_longer |>    filter(h2 == 0.25, b2 == 0.25, Generation == \"G5\") |>    mutate(     label = recode(`Selection Type`,                    B = \"BV[m]\",                    G = \"BV[d]\",                    TBV = \"BV[t]\",                    None = \"Random\")) p1 <- phenotypes_longer |>    ggplot(aes(x = Generation, y = `Y mean`, group = `Selection Type`, color = `Selection Type`)) +    geom_point(size = 0.5) +    geom_line(alpha = 0.5)  +   geom_smooth(method = \"lm\", se = TRUE, linetype = 0, aes(fill = `Selection Type`), alpha = 0.2)+   geom_text_repel(data = labels,              aes(label = label), parse = T, hjust = -1, vjust = -0.8, direction = \"y\", segment.color = \"grey80\") +    labs(y = \"Mean phenotype change\") +   theme(panel.background = element_rect(fill=\"white\"),         panel.grid.major = element_line(colour=\"#e3e3e3\"),         panel.grid.minor.y = element_blank(),         panel.grid.major.x = element_blank(),          panel.grid.minor.x = element_blank(),          strip.text = element_text(size=12),         axis.title = element_text(size = 12),         axis.text = element_text(size=12),         plot.title = element_text(size=12),         legend.position = \"none\")  +   facet_grid(rows = vars(h2),               cols = vars(b2),               drop = TRUE,               labeller = custom_labeller,              switch = \"y\") +   scale_y_continuous(position = \"right\") +   scale_color_manual(values = colours) +   scale_fill_manual(values = colours) +   coord_cartesian(clip = \"off\") p1"},{"path":"/articles/generate-figures.html","id":"selection-index-based-on-a-combination-of-trait-and-diversity-metrics","dir":"Articles","previous_headings":"","what":"Selection index based on a combination of trait and diversity metrics","title":"Generate figures","text":"first demonstration usefulness RITHMS, consider practical case study complex breeding program multi-trait objective: maximizing phenotypic change perserving microbial α\\alpha-diversity. section matches code Figure 6 paper. iteration, look diversity phenotype values. look differences two traits base population last generation generation.","code":"#n_it = 25 was used to generate the figure of the article n_it = 1 set.seed(40) vec_seed <- sample(100:10000,n_it) params_df <- tibble::tribble(    ~div,  ~TBV,    0,    1,    1,    0,    0.5, 0.5,    0.8, 0.2,    0.2, 0.8,    0.7, 0.3,    0.3, 0.7,    0.4, 0.6,    0.6, 0.4,    0.1, 0.9,    0.9, 0.1   ) |> crossing(tibble(seed = vec_seed)) |>    mutate(sim_ID = row_number(), .before = \"div\") %>%    mutate(concatenated = glue(\"({div},{TBV})\"))  noise = 0.6 effect.size = 0.3 lambda = 0.5  mean_phenotypes_y <- data_frame() diversities_microbiomes <- data_frame() #Could be functionalized and parallelized as done in previous section for (i in 1:nrow(params_df)) {  taxa_assign_g <- assign_taxa(founder_object)      generations_simu <- holo_simu(h2 = 0.25,                                 b2 = 0.25,                                 founder_object = founder_object,                                 n_clust = taxa_assign_g,                                 n_ind = 500,                                 verbose = F,                                 noise.microbiome = noise,                                 effect.size = effect.size,                                 lambda = lambda,                                 selection = T,                                 dir = T,                                 size_selection_F = 0.3,                                 size_selection_M = 0.3,                                 selection_type = \"div.GB\",                                 w.param = c(as.numeric(params_df[i,2]), as.numeric(params_df[i,3])),                                 seed = as.numeric(params_df[i,4]))   mean_phenotypes_y <- rbind(mean_phenotypes_y,                               generations_simu[-1] %>% map(get_mean_phenotypes) %>% bind_rows(.id = \"Generation\"))   diversities_microbiomes <- rbind(diversities_microbiomes,                                    generations_simu[-1] %>% map(get_microbiomes) %>% map(richness_from_abundances_gen) |> map(get_mean_diversity) %>% bind_rows(.id = \"Generation\"))   } diff_y <- mean_phenotypes_y$G5 - mean_phenotypes_y$G0 diff_div <- diversities_microbiomes$G5 - diversities_microbiomes$G0 diff_data <- cbind(diff_y = diff_y,                    diff_div = diff_div) %>%   as.data.frame() %>%   mutate(category = params_df$concatenated)  diff_data_concat <- diff_data %>% summarise(mean_div = mean(diff_div),                                              mean_y = mean(diff_y),                                              sd_div = (1.96 * sd(diff_div)/sqrt(n())),                                             sd_y = (1.96 * sd(diff_y)/sqrt(n())),                                             .by = c(category)) p <- diff_data %>%   mutate(w = str_remove_all(category, \"\\\\(|,.*\") |> as.numeric()) |>    ggplot(aes(y = diff_y, x = diff_div,               colour = w              )) +   geom_point(alpha = 0.4, shape = 20, size = 3) +   geom_point(data = diff_data_concat |> mutate(w = str_remove_all(category, \"\\\\(|,.*\") |> as.numeric()),               aes(y = mean_y, x = mean_div),               shape = 15, size = 5) +   geom_line(data = diff_data_concat |>  mutate(w = str_remove_all(category, \"\\\\(|,.*\") |> as.numeric()),              aes(y = mean_y, x = mean_div, group = 1), show.legend = FALSE) +   geom_vline(xintercept = 0, linetype = 2, color = \"darkgrey\") +   geom_hline(yintercept = 0, linetype = 2, color = \"darkgrey\") +    theme(     panel.background = element_rect(fill = \"white\"),     panel.grid.major = element_line(colour = \"#e3e3e3\"),     panel.grid.minor = element_line(colour = \"#e9e9e9\"),     axis.title = element_text(size = 12, face = \"bold\"),     axis.text = element_text(size = 10),     plot.title = element_text(size = 10, face = \"bold\"),     legend.key.size = unit(0.3, 'cm'),     legend.title = element_text(size = 12, face = \"bold\"),      legend.text = element_text(size = 10),     legend.position = \"inside\",     legend.position.inside = c(0.49, 0.02),     legend.justification.inside = c(0.5, 0),      legend.direction = \"horizontal\",     legend.box = \"horizontal\",   ) +   labs(     y = \"Mean phenotype change (over 5 generations)\",     x = \"Microbial diversity change (over 5 generations)\",     colour = expression(w[div])   ) +    scale_color_viridis_c(option = \"D\",                          breaks = seq(0,1,0.1),                         name = expression(w[div]),                         labels = seq(0,1,0.1)) +   coord_cartesian(clip = \"off\") +   theme(legend.key.width = unit(25, \"mm\"),         legend.background = element_rect(fill = \"transparent\")) +   NULL  p"},{"path":[]},{"path":[]},{"path":[]},{"path":"/articles/get-started.html","id":"taxa-assignation-function","dir":"Articles","previous_headings":"Pre-Simulation functions","what":"Taxa assignation function","title":"Get started","text":"","code":"# library(dplyr) # datafile <- system.file(\"BesePopTest.rds\", package = \"RITHMS\") # ToyData <- readRDS(datafile) # assign_taxa(founder_object = ToyData, #             taxa_g = 0.2)"},{"path":[]},{"path":[]},{"path":[]},{"path":[]},{"path":[]},{"path":[]},{"path":"/articles/get-started.html","id":"inflate-your-package","dir":"Articles","previous_headings":"","what":"Inflate your package","title":"Get started","text":"’re one inflate paper box. Build package Rmd using fusen::inflate() Verify \"DESCRIPTION\" file updated Verify function \"R/\" directory Verify test \"tests/testthat/\" directory Verify Rmd appears \"vignettes/\" directory","code":""},{"path":"/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Solène Pety. Author, maintainer, copyright holder. Ingrid David. Author, thesis advisor. Mahendra Mariadassou. Author, thesis advisor. Andrea Rau. Author, thesis advisor.","code":""},{"path":"/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Pety S, David , Mariadassou M, Rau (2025). RITHMS: Advanced Stochastic Framework Simulation Transgenerational Hologenomic Data. R package version 0.0.0.9000.","code":"@Manual{,   title = {RITHMS: An Advanced Stochastic Framework for the Simulation of Transgenerational Hologenomic Data},   author = {Solène Pety and Ingrid David and Mahendra Mariadassou and Andrea Rau},   year = {2025},   note = {R package version 0.0.0.9000}, }"},{"path":"/index.html","id":"rithms-","dir":"","previous_headings":"","what":"An Advanced Stochastic Framework for the Simulation of Transgenerational Hologenomic Data","title":"An Advanced Stochastic Framework for the Simulation of Transgenerational Hologenomic Data","text":"framework, R Implementation Transgenerational Hologenomic Model-based Simulator (RITHMS) open-source package, builds upon MoBPS package incorporates distinctive architecture microbiota, notably vertical horizontal transfer well modulation due environment host genetics. addition, RITHMS can account variety selection strategies, adaptable different genetic architectures. Full documentation website : https://SolenePety.github.io/RITHMS Last code version : https://github.com/SolenePety/RITHMS little summary RITHMS work, can read preprint details.","code":""},{"path":"/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"An Advanced Stochastic Framework for the Simulation of Transgenerational Hologenomic Data","text":"can install development version RITHMS GitHub using devtools :","code":"# install.packages(\"devtools\") devtools::install_github(\"SolenePety/RITHMS\")"},{"path":"/index.html","id":"example","dir":"","previous_headings":"","what":"Example","title":"An Advanced Stochastic Framework for the Simulation of Transgenerational Hologenomic Data","text":"basic example shows solve common problem: already toy dataset, subset Déru et al. 2020, 1845 species 780 individuals, show expected structure input data : can much … can check also vignette generate figures coming article","code":"library(RITHMS) datafile <- system.file(\"DeruPop.rds\", package = \"RITHMS\") ToyData <- readRDS(datafile)"},{"path":"/reference/compute_beta_g.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute product of matrixes based on few parameters — compute_beta_g","title":"Compute product of matrixes based on few parameters — compute_beta_g","text":"Compute product matrixes based parameters","code":""},{"path":"/reference/compute_beta_g.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute product of matrixes based on few parameters — compute_beta_g","text":"","code":"compute_beta_g(beta, genotypes, noise, taxa_scale)"},{"path":"/reference/compute_current_microbiome.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute microbiomes for all individuals of current generation gathering all relevant object already computed. — compute_current_microbiome","title":"Compute microbiomes for all individuals of current generation gathering all relevant object already computed. — compute_current_microbiome","text":"Compute microbiomes individuals current generation gathering relevant object already computed.","code":""},{"path":"/reference/compute_current_microbiome.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute microbiomes for all individuals of current generation gathering all relevant object already computed. — compute_current_microbiome","text":"","code":"compute_current_microbiome(   beta,   current_genotypes,   mother_microbiomes,   mean_microbiome,   noise = 0.1,   taxa_scale,   lambda = 0.5,   dir = F,   thetaX )"},{"path":"/reference/compute_current_microbiome.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute microbiomes for all individuals of current generation gathering all relevant object already computed. — compute_current_microbiome","text":"lambda proportion microbiome offspring coming vertical transmission, DEFAULT = 0.5 dir bool thetaX environmental effect","code":""},{"path":"/reference/compute_mean_microbiome.html","id":null,"dir":"Reference","previous_headings":"","what":"apply mean on rows for each taxa across population — compute_mean_microbiome","title":"apply mean on rows for each taxa across population — compute_mean_microbiome","text":"apply mean rows taxa across population","code":""},{"path":"/reference/compute_mean_microbiome.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"apply mean on rows for each taxa across population — compute_mean_microbiome","text":"","code":"compute_mean_microbiome(microbiome, dir = F, n_ind = NULL, ao, mix.params)"},{"path":"/reference/compute_mean_microbiome.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"apply mean on rows for each taxa across population — compute_mean_microbiome","text":"dir bool n_ind number individual per generation ao dirichlet sampling parameter mix.params Vector two values giving weights regularisation base population microbiome. mix.params1 = weight raw microbiome mix.params2 = weight mean microbiome. DEFAULT = c(0.75,0.25)","code":""},{"path":"/reference/compute_phenotypes.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute phenotype values based on generated object of current generation — compute_phenotypes","title":"Compute phenotype values based on generated object of current generation — compute_phenotypes","text":"Compute phenotype values based generated object current generation","code":""},{"path":"/reference/compute_phenotypes.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute phenotype values based on generated object of current generation — compute_phenotypes","text":"","code":"compute_phenotypes(   X,   B,   otu_list,   qtl_list,   beta_qtl,   beta_otu,   Nqtl_y,   Notu_y,   se )"},{"path":"/reference/formatting_data.html","id":null,"dir":"Reference","previous_headings":"","what":"Assign all taxa to a cluster, eventually under genetic control using hclust — assign_taxa","title":"Assign all taxa to a cluster, eventually under genetic control using hclust — assign_taxa","text":"Assign taxa cluster, eventually genetic control using hclust","code":""},{"path":"/reference/formatting_data.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Assign all taxa to a cluster, eventually under genetic control using hclust — assign_taxa","text":"","code":"assign_taxa(founder_object, taxa_g = 0.05)"},{"path":"/reference/formatting_data.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Assign all taxa to a cluster, eventually under genetic control using hclust — assign_taxa","text":"founder_object Output read_input_data function taxa_g Percentage taxa genetic control, DEFAULT = 0.1","code":""},{"path":"/reference/formatting_data.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Assign all taxa to a cluster, eventually under genetic control using hclust — assign_taxa","text":"vector length matching total number taxa values 0 number taxa, 0 corresponding non genetic control cluster","code":""},{"path":"/reference/formatting_data.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Assign all taxa to a cluster, eventually under genetic control using hclust — assign_taxa","text":"","code":"# library(dplyr) # datafile <- system.file(\"BesePopTest.rds\", package = \"RITHMS\") # ToyData <- readRDS(datafile) # assign_taxa(founder_object = ToyData, #             taxa_g = 0.2)"},{"path":"/reference/gen_effect_calibration.html","id":null,"dir":"Reference","previous_headings":"","what":"Calibration of genetic effect from founder population data — gen_effect_calibration","title":"Calibration of genetic effect from founder population data — gen_effect_calibration","text":"Calibration genetic effect founder population data","code":""},{"path":"/reference/gen_effect_calibration.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calibration of genetic effect from founder population data — gen_effect_calibration","text":"","code":"gen_effect_calibration(   founder_object,   taxa_assign_g,   correlation = 0.5,   effect.size = c(seq(0.1, 1, 0.1)),   plot = T )"},{"path":"/reference/gen_effect_calibration.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calibration of genetic effect from founder population data — gen_effect_calibration","text":"founder_object Output generate_founder() function taxa_assign_g Factor vector giving cluster assignment taxa, typical output assign_taxa() correlation Correlation taxa within cluster, value 0 1, DEFAULT = 0.5 effect.size Vector giving size genetic effect try plot boolean, plot generation required, DEFAULT = TRUE","code":""},{"path":"/reference/gen_effect_calibration.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calibration of genetic effect from founder population data — gen_effect_calibration","text":"data.frame three columns, giving Taxa ID, effect.size corresponding heritability","code":""},{"path":"/reference/generate_founder.html","id":null,"dir":"Reference","previous_headings":"","what":"Formatting of ped and map files into haplotypes table and filter individuals — generate_founder","title":"Formatting of ped and map files into haplotypes table and filter individuals — generate_founder","text":"Formatting ped map files haplotypes table filter individuals","code":""},{"path":"/reference/generate_founder.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Formatting of ped and map files into haplotypes table and filter individuals — generate_founder","text":"","code":"generate_founder(path = NULL, microbiote_matrix)"},{"path":"/reference/get_mean_diversity.html","id":null,"dir":"Reference","previous_headings":"","what":"Useful function to extract Shannon diversity from RITHMS output — get_mean_diversity","title":"Useful function to extract Shannon diversity from RITHMS output — get_mean_diversity","text":"Useful function extract Shannon diversity RITHMS output","code":""},{"path":"/reference/get_mean_diversity.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Useful function to extract Shannon diversity from RITHMS output — get_mean_diversity","text":"","code":"get_mean_diversity(data)"},{"path":"/reference/get_mean_phenotypes.html","id":null,"dir":"Reference","previous_headings":"","what":"Useful function to extract mean phenotype values from RITHMS output — get_mean_phenotypes","title":"Useful function to extract mean phenotype values from RITHMS output — get_mean_phenotypes","text":"Useful function extract mean phenotype values RITHMS output","code":""},{"path":"/reference/get_mean_phenotypes.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Useful function to extract mean phenotype values from RITHMS output — get_mean_phenotypes","text":"","code":"get_mean_phenotypes(data)"},{"path":"/reference/get_microbiomes.html","id":null,"dir":"Reference","previous_headings":"","what":"Useful function to extract microbiomes from RITHMS output — get_microbiomes","title":"Useful function to extract microbiomes from RITHMS output — get_microbiomes","text":"Useful function extract microbiomes RITHMS output","code":""},{"path":"/reference/get_microbiomes.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Useful function to extract microbiomes from RITHMS output — get_microbiomes","text":"","code":"get_microbiomes(data, transpose = F, CLR = F)"},{"path":"/reference/get_om_beta_g.html","id":null,"dir":"Reference","previous_headings":"","what":"Useful function to extract omega beta G values from RITHMS output — get_om_beta_g","title":"Useful function to extract omega beta G values from RITHMS output — get_om_beta_g","text":"Useful function extract omega beta G values RITHMS output","code":""},{"path":"/reference/get_om_beta_g.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Useful function to extract omega beta G values from RITHMS output — get_om_beta_g","text":"","code":"get_om_beta_g(data)"},{"path":"/reference/get_phenotypes.html","id":null,"dir":"Reference","previous_headings":"","what":"Useful function to extract all phenotype values as data frame from RITHMS output — get_phenotypes","title":"Useful function to extract all phenotype values as data frame from RITHMS output — get_phenotypes","text":"Useful function extract phenotype values data frame RITHMS output","code":""},{"path":"/reference/get_phenotypes.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Useful function to extract all phenotype values as data frame from RITHMS output — get_phenotypes","text":"","code":"get_phenotypes(data)"},{"path":"/reference/get_phenotypes_value.html","id":null,"dir":"Reference","previous_headings":"","what":"Useful function to extract phenotype values from RITHMS output (","title":"Useful function to extract phenotype values from RITHMS output (","text":"Useful function extract phenotype values RITHMS output (\"gq\" default)","code":""},{"path":"/reference/get_phenotypes_value.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Useful function to extract phenotype values from RITHMS output (","text":"","code":"get_phenotypes_value(data, value = \"gq\")"},{"path":"/reference/get_selected_ind.html","id":null,"dir":"Reference","previous_headings":"","what":"Useful function to extract ID of selected individuals from RITHMS output — get_selected_ind","title":"Useful function to extract ID of selected individuals from RITHMS output — get_selected_ind","text":"Useful function extract ID selected individuals RITHMS output","code":""},{"path":"/reference/get_selected_ind.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Useful function to extract ID of selected individuals from RITHMS output — get_selected_ind","text":"","code":"get_selected_ind(data)"},{"path":"/reference/holo_simu.html","id":null,"dir":"Reference","previous_headings":"","what":"Main function to generate transgenerational hologenomic data — holo_simu","title":"Main function to generate transgenerational hologenomic data — holo_simu","text":"Main function generate transgenerational hologenomic data","code":""},{"path":"/reference/holo_simu.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Main function to generate transgenerational hologenomic data — holo_simu","text":"","code":"holo_simu(   h2,   b2,   founder_object,   otu_g = 0.05,   qtn_y = NULL,   n_ind = NULL,   n_gen = 5,   n_clust = NULL,   selection = F,   size_selection_F = NULL,   size_selection_M = NULL,   selection_type = \"GB\",   seed = 1234,   verbose = T,   lambda = 0.5,   correlation = 0.5,   mix.params = c(0.75, 0.25),   mix.params.M = c(0.75, 0.25),   effect.size = 0.1,   noise.microbiome = 0.1,   dir = F,   ao = 25,   thetaX = NULL,   env_gen = NULL,   w.param = c(0.5, 0.5) )"},{"path":"/reference/holo_simu.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Main function to generate transgenerational hologenomic data — holo_simu","text":"h2 direct heritability value, 0 1 b2 microbiability value, 0 1 founder_object output generate_founder() function otu_g percentage taxa genetic control, 0 1, DEFAULT = 0.05 qtn_y number causal SNPs phenotypes n_ind number individual per generation n_gen number generation, DEFAULT = 5 n_clust vector taxa assignment, typical output assign_taxa selection bool, selection process needed, DEFAULT = FALSE size_selection_F percentage female select size_selection_M percentage male select selection_type mode selection used, value (\"GB\", \"B\", \"G\", \"diversity\", \"div.GB\"), DEFAULT = \"GB\" seed seed value samplings function verbose bool, DEFAULT = T lambda proportion microbiome offspring coming vertical transmission, DEFAULT = 0.5 correlation Correlation taxa within cluster, value 0 1, DEFAULT = 0.5 mix.params Vector two values giving weights regularisation base population microbiome. mix.params1 = weight raw microbiome mix.params2 = weight mean microbiome. DEFAULT = c(0.75,0.25) noise.microbiome sd microbiome noise, DEFAULT = 0.1 dir bool ao dirichlet sampling parameter thetaX environmental effect env_gen vector bool w.param case div.GB selection mode chosen","code":""},{"path":"/reference/holo_simu.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Main function to generate transgenerational hologenomic data — holo_simu","text":"big list object metada info beta matrix details generation level 1. generation, genotypes, microbiomes, phenotypes, pedigree individuals selected can reachable.","code":""},{"path":"/reference/read_input_data.html","id":null,"dir":"Reference","previous_headings":"","what":"Formatting data from file paths to base population object — read_input_data","title":"Formatting data from file paths to base population object — read_input_data","text":"Formatting data file paths base population object","code":""},{"path":"/reference/read_input_data.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Formatting data from file paths to base population object — read_input_data","text":"","code":"read_input_data(   path_to_microbiome,   path_to_pedmap,   threshold = 0.05,   ind_selected = NULL )"},{"path":"/reference/read_input_data.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Formatting data from file paths to base population object — read_input_data","text":"path_to_microbiome String giving path count table file path_to_pedmap String giving path prefix ped map file threshold Threshold rarefaction, DEFAULT = 0.05 ind_selected Vector string values individuals keep, match rownames count table file, DEFAULT = NULL","code":""},{"path":"/reference/read_input_data.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Formatting data from file paths to base population object — read_input_data","text":"data.frame corresponding (rarefied) microbiome individuals rows taxa columns. Genotypes data.frame attribute called \"population\" reachable using attr(output_name,\"population\")","code":""},{"path":"/reference/replace_zero.html","id":null,"dir":"Reference","previous_headings":"","what":"Replace zero in the matrix by 1e-15 to avoid infinite values when CLR transformation is computed — replace_zero","title":"Replace zero in the matrix by 1e-15 to avoid infinite values when CLR transformation is computed — replace_zero","text":"Replace zero matrix 1e-15 avoid infinite values CLR transformation computed","code":""},{"path":"/reference/replace_zero.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Replace zero in the matrix by 1e-15 to avoid infinite values when CLR transformation is computed — replace_zero","text":"","code":"replace_zero(x)"},{"path":"/reference/richness_from_abundances_gen.html","id":null,"dir":"Reference","previous_headings":"","what":"If selection based on diversity, need to go back to counts using multinomial sampling from abundances. — richness_from_abundances_gen","title":"If selection based on diversity, need to go back to counts using multinomial sampling from abundances. — richness_from_abundances_gen","text":"selection based diversity, need go back counts using multinomial sampling abundances.","code":""},{"path":"/reference/richness_from_abundances_gen.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"If selection based on diversity, need to go back to counts using multinomial sampling from abundances. — richness_from_abundances_gen","text":"","code":"richness_from_abundances_gen(microbiome_matrix, n_loop = 10, plot = T)"},{"path":"/reference/root.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute root value for beta matrix construction — root","title":"Compute root value for beta matrix construction — root","text":"Compute root value beta matrix construction","code":""},{"path":"/reference/root.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute root value for beta matrix construction — root","text":"","code":"root(rho)"},{"path":"/reference/select_individual.html","id":null,"dir":"Reference","previous_headings":"","what":"Obtain id of the parents selected for the next generation based on the criteria chosen by the user — select_individual","title":"Obtain id of the parents selected for the next generation based on the criteria chosen by the user — select_individual","text":"Obtain id parents selected next generation based criteria chosen user","code":""},{"path":"/reference/select_individual.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Obtain id of the parents selected for the next generation based on the criteria chosen by the user — select_individual","text":"","code":"select_individual(   phenotypes,   microbiomes,   genotypes,   beta,   beta_otu,   selection,   size_selection_F,   size_selection_M,   selection_type,   w.param )"},{"path":"/reference/select_individual.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Obtain id of the parents selected for the next generation based on the criteria chosen by the user — select_individual","text":"selection bool, selection process needed, DEFAULT = FALSE size_selection_F percentage female select size_selection_M percentage male select selection_type mode selection used, value (\"GB\", \"B\", \"G\", \"diversity\", \"div.GB\"), DEFAULT = \"GB\" w.param case div.GB selection mode chosen","code":""},{"path":"/news/index.html","id":"rithms-development-version","dir":"Changelog","previous_headings":"","what":"RITHMS (development version)","title":"RITHMS (development version)","text":"Initial CRAN submission.","code":""}]
