[{"path":[]},{"path":"/CODE_OF_CONDUCT.html","id":"our-pledge","dir":"","previous_headings":"","what":"Our Pledge","title":"Contributor Covenant Code of Conduct","text":"members, contributors, leaders pledge make participation community harassment-free experience everyone, regardless age, body size, visible invisible disability, ethnicity, sex characteristics, gender identity expression, level experience, education, socio-economic status, nationality, personal appearance, race, caste, color, religion, sexual identity orientation. pledge act interact ways contribute open, welcoming, diverse, inclusive, healthy community.","code":""},{"path":"/CODE_OF_CONDUCT.html","id":"our-standards","dir":"","previous_headings":"","what":"Our Standards","title":"Contributor Covenant Code of Conduct","text":"Examples behavior contributes positive environment community include: Demonstrating empathy kindness toward people respectful differing opinions, viewpoints, experiences Giving gracefully accepting constructive feedback Accepting responsibility apologizing affected mistakes, learning experience Focusing best just us individuals, overall community Examples unacceptable behavior include: use sexualized language imagery, sexual attention advances kind Trolling, insulting derogatory comments, personal political attacks Public private harassment Publishing others‚Äô private information, physical email address, without explicit permission conduct reasonably considered inappropriate professional setting","code":""},{"path":"/CODE_OF_CONDUCT.html","id":"enforcement-responsibilities","dir":"","previous_headings":"","what":"Enforcement Responsibilities","title":"Contributor Covenant Code of Conduct","text":"Community leaders responsible clarifying enforcing standards acceptable behavior take appropriate fair corrective action response behavior deem inappropriate, threatening, offensive, harmful. Community leaders right responsibility remove, edit, reject comments, commits, code, wiki edits, issues, contributions aligned Code Conduct, communicate reasons moderation decisions appropriate.","code":""},{"path":"/CODE_OF_CONDUCT.html","id":"scope","dir":"","previous_headings":"","what":"Scope","title":"Contributor Covenant Code of Conduct","text":"Code Conduct applies within community spaces, also applies individual officially representing community public spaces. Examples representing community include using official e-mail address, posting via official social media account, acting appointed representative online offline event.","code":""},{"path":"/CODE_OF_CONDUCT.html","id":"enforcement","dir":"","previous_headings":"","what":"Enforcement","title":"Contributor Covenant Code of Conduct","text":"Instances abusive, harassing, otherwise unacceptable behavior may reported community leaders responsible enforcement contact@fake.com. complaints reviewed investigated promptly fairly. community leaders obligated respect privacy security reporter incident.","code":""},{"path":"/CODE_OF_CONDUCT.html","id":"enforcement-guidelines","dir":"","previous_headings":"","what":"Enforcement Guidelines","title":"Contributor Covenant Code of Conduct","text":"Community leaders follow Community Impact Guidelines determining consequences action deem violation Code Conduct:","code":""},{"path":"/CODE_OF_CONDUCT.html","id":"id_1-correction","dir":"","previous_headings":"Enforcement Guidelines","what":"1. Correction","title":"Contributor Covenant Code of Conduct","text":"Community Impact: Use inappropriate language behavior deemed unprofessional unwelcome community. Consequence: private, written warning community leaders, providing clarity around nature violation explanation behavior inappropriate. public apology may requested.","code":""},{"path":"/CODE_OF_CONDUCT.html","id":"id_2-warning","dir":"","previous_headings":"Enforcement Guidelines","what":"2. Warning","title":"Contributor Covenant Code of Conduct","text":"Community Impact: violation single incident series actions. Consequence: warning consequences continued behavior. interaction people involved, including unsolicited interaction enforcing Code Conduct, specified period time. includes avoiding interactions community spaces well external channels like social media. Violating terms may lead temporary permanent ban.","code":""},{"path":"/CODE_OF_CONDUCT.html","id":"id_3-temporary-ban","dir":"","previous_headings":"Enforcement Guidelines","what":"3. Temporary Ban","title":"Contributor Covenant Code of Conduct","text":"Community Impact: serious violation community standards, including sustained inappropriate behavior. Consequence: temporary ban sort interaction public communication community specified period time. public private interaction people involved, including unsolicited interaction enforcing Code Conduct, allowed period. Violating terms may lead permanent ban.","code":""},{"path":"/CODE_OF_CONDUCT.html","id":"id_4-permanent-ban","dir":"","previous_headings":"Enforcement Guidelines","what":"4. Permanent Ban","title":"Contributor Covenant Code of Conduct","text":"Community Impact: Demonstrating pattern violation community standards, including sustained inappropriate behavior, harassment individual, aggression toward disparagement classes individuals. Consequence: permanent ban sort public interaction within community.","code":""},{"path":"/CODE_OF_CONDUCT.html","id":"attribution","dir":"","previous_headings":"","what":"Attribution","title":"Contributor Covenant Code of Conduct","text":"Code Conduct adapted Contributor Covenant, version 2.1, available https://www.contributor-covenant.org/version/2/1/code_of_conduct.html. Community Impact Guidelines inspired [Mozilla‚Äôs code conduct enforcement ladder][https://github.com/mozilla/inclusion]. answers common questions code conduct, see FAQ https://www.contributor-covenant.org/faq. Translations available https://www.contributor-covenant.org/translations.","code":""},{"path":"/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"GNU General Public License","title":"GNU General Public License","text":"Version 3, 29 June 2007Copyright ¬© 2007 Free Software Foundation, Inc.¬†<http://fsf.org/> Everyone permitted copy distribute verbatim copies license document, changing allowed.","code":""},{"path":"/LICENSE.html","id":"preamble","dir":"","previous_headings":"","what":"Preamble","title":"GNU General Public License","text":"GNU General Public License free, copyleft license software kinds works. licenses software practical works designed take away freedom share change works. contrast, GNU General Public License intended guarantee freedom share change versions program‚Äìmake sure remains free software users. , Free Software Foundation, use GNU General Public License software; applies also work released way authors. can apply programs, . speak free software, referring freedom, price. General Public Licenses designed make sure freedom distribute copies free software (charge wish), receive source code can get want , can change software use pieces new free programs, know can things. protect rights, need prevent others denying rights asking surrender rights. Therefore, certain responsibilities distribute copies software, modify : responsibilities respect freedom others. example, distribute copies program, whether gratis fee, must pass recipients freedoms received. must make sure , , receive can get source code. must show terms know rights. Developers use GNU GPL protect rights two steps: (1) assert copyright software, (2) offer License giving legal permission copy, distribute /modify . developers‚Äô authors‚Äô protection, GPL clearly explains warranty free software. users‚Äô authors‚Äô sake, GPL requires modified versions marked changed, problems attributed erroneously authors previous versions. devices designed deny users access install run modified versions software inside , although manufacturer can . fundamentally incompatible aim protecting users‚Äô freedom change software. systematic pattern abuse occurs area products individuals use, precisely unacceptable. Therefore, designed version GPL prohibit practice products. problems arise substantially domains, stand ready extend provision domains future versions GPL, needed protect freedom users. Finally, every program threatened constantly software patents. States allow patents restrict development use software general-purpose computers, , wish avoid special danger patents applied free program make effectively proprietary. prevent , GPL assures patents used render program non-free. precise terms conditions copying, distribution modification follow.","code":""},{"path":[]},{"path":"/LICENSE.html","id":"id_0-definitions","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"0. Definitions","title":"GNU General Public License","text":"‚ÄúLicense‚Äù refers version 3 GNU General Public License. ‚ÄúCopyright‚Äù also means copyright-like laws apply kinds works, semiconductor masks. ‚ÄúProgram‚Äù refers copyrightable work licensed License. licensee addressed ‚Äú‚Äù. ‚ÄúLicensees‚Äù ‚Äúrecipients‚Äù may individuals organizations. ‚Äúmodify‚Äù work means copy adapt part work fashion requiring copyright permission, making exact copy. resulting work called ‚Äúmodified version‚Äù earlier work work ‚Äúbased ‚Äù earlier work. ‚Äúcovered work‚Äù means either unmodified Program work based Program. ‚Äúpropagate‚Äù work means anything , without permission, make directly secondarily liable infringement applicable copyright law, except executing computer modifying private copy. Propagation includes copying, distribution (without modification), making available public, countries activities well. ‚Äúconvey‚Äù work means kind propagation enables parties make receive copies. Mere interaction user computer network, transfer copy, conveying. interactive user interface displays ‚ÄúAppropriate Legal Notices‚Äù extent includes convenient prominently visible feature (1) displays appropriate copyright notice, (2) tells user warranty work (except extent warranties provided), licensees may convey work License, view copy License. interface presents list user commands options, menu, prominent item list meets criterion.","code":""},{"path":"/LICENSE.html","id":"id_1-source-code","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"1. Source Code","title":"GNU General Public License","text":"‚Äúsource code‚Äù work means preferred form work making modifications . ‚ÄúObject code‚Äù means non-source form work. ‚ÄúStandard Interface‚Äù means interface either official standard defined recognized standards body, , case interfaces specified particular programming language, one widely used among developers working language. ‚ÄúSystem Libraries‚Äù executable work include anything, work whole, () included normal form packaging Major Component, part Major Component, (b) serves enable use work Major Component, implement Standard Interface implementation available public source code form. ‚ÄúMajor Component‚Äù, context, means major essential component (kernel, window system, ) specific operating system () executable work runs, compiler used produce work, object code interpreter used run . ‚ÄúCorresponding Source‚Äù work object code form means source code needed generate, install, (executable work) run object code modify work, including scripts control activities. However, include work‚Äôs System Libraries, general-purpose tools generally available free programs used unmodified performing activities part work. example, Corresponding Source includes interface definition files associated source files work, source code shared libraries dynamically linked subprograms work specifically designed require, intimate data communication control flow subprograms parts work. Corresponding Source need include anything users can regenerate automatically parts Corresponding Source. Corresponding Source work source code form work.","code":""},{"path":"/LICENSE.html","id":"id_2-basic-permissions","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"2. Basic Permissions","title":"GNU General Public License","text":"rights granted License granted term copyright Program, irrevocable provided stated conditions met. License explicitly affirms unlimited permission run unmodified Program. output running covered work covered License output, given content, constitutes covered work. License acknowledges rights fair use equivalent, provided copyright law. may make, run propagate covered works convey, without conditions long license otherwise remains force. may convey covered works others sole purpose make modifications exclusively , provide facilities running works, provided comply terms License conveying material control copyright. thus making running covered works must exclusively behalf, direction control, terms prohibit making copies copyrighted material outside relationship . Conveying circumstances permitted solely conditions stated . Sublicensing allowed; section 10 makes unnecessary.","code":""},{"path":"/LICENSE.html","id":"id_3-protecting-users-legal-rights-from-anti-circumvention-law","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"3. Protecting Users‚Äô Legal Rights From Anti-Circumvention Law","title":"GNU General Public License","text":"covered work shall deemed part effective technological measure applicable law fulfilling obligations article 11 WIPO copyright treaty adopted 20 December 1996, similar laws prohibiting restricting circumvention measures. convey covered work, waive legal power forbid circumvention technological measures extent circumvention effected exercising rights License respect covered work, disclaim intention limit operation modification work means enforcing, work‚Äôs users, third parties‚Äô legal rights forbid circumvention technological measures.","code":""},{"path":"/LICENSE.html","id":"id_4-conveying-verbatim-copies","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"4. Conveying Verbatim Copies","title":"GNU General Public License","text":"may convey verbatim copies Program‚Äôs source code receive , medium, provided conspicuously appropriately publish copy appropriate copyright notice; keep intact notices stating License non-permissive terms added accord section 7 apply code; keep intact notices absence warranty; give recipients copy License along Program. may charge price price copy convey, may offer support warranty protection fee.","code":""},{"path":"/LICENSE.html","id":"id_5-conveying-modified-source-versions","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"5. Conveying Modified Source Versions","title":"GNU General Public License","text":"may convey work based Program, modifications produce Program, form source code terms section 4, provided also meet conditions: ) work must carry prominent notices stating modified , giving relevant date. b) work must carry prominent notices stating released License conditions added section 7. requirement modifies requirement section 4 ‚Äúkeep intact notices‚Äù. c) must license entire work, whole, License anyone comes possession copy. License therefore apply, along applicable section 7 additional terms, whole work, parts, regardless packaged. License gives permission license work way, invalidate permission separately received . d) work interactive user interfaces, must display Appropriate Legal Notices; however, Program interactive interfaces display Appropriate Legal Notices, work need make . compilation covered work separate independent works, nature extensions covered work, combined form larger program, volume storage distribution medium, called ‚Äúaggregate‚Äù compilation resulting copyright used limit access legal rights compilation‚Äôs users beyond individual works permit. Inclusion covered work aggregate cause License apply parts aggregate.","code":""},{"path":"/LICENSE.html","id":"id_6-conveying-non-source-forms","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"6. Conveying Non-Source Forms","title":"GNU General Public License","text":"may convey covered work object code form terms sections 4 5, provided also convey machine-readable Corresponding Source terms License, one ways: ) Convey object code , embodied , physical product (including physical distribution medium), accompanied Corresponding Source fixed durable physical medium customarily used software interchange. b) Convey object code , embodied , physical product (including physical distribution medium), accompanied written offer, valid least three years valid long offer spare parts customer support product model, give anyone possesses object code either (1) copy Corresponding Source software product covered License, durable physical medium customarily used software interchange, price reasonable cost physically performing conveying source, (2) access copy Corresponding Source network server charge. c) Convey individual copies object code copy written offer provide Corresponding Source. alternative allowed occasionally noncommercially, received object code offer, accord subsection 6b. d) Convey object code offering access designated place (gratis charge), offer equivalent access Corresponding Source way place charge. need require recipients copy Corresponding Source along object code. place copy object code network server, Corresponding Source may different server (operated third party) supports equivalent copying facilities, provided maintain clear directions next object code saying find Corresponding Source. Regardless server hosts Corresponding Source, remain obligated ensure available long needed satisfy requirements. e) Convey object code using peer--peer transmission, provided inform peers object code Corresponding Source work offered general public charge subsection 6d. separable portion object code, whose source code excluded Corresponding Source System Library, need included conveying object code work. ‚ÄúUser Product‚Äù either (1) ‚Äúconsumer product‚Äù, means tangible personal property normally used personal, family, household purposes, (2) anything designed sold incorporation dwelling. determining whether product consumer product, doubtful cases shall resolved favor coverage. particular product received particular user, ‚Äúnormally used‚Äù refers typical common use class product, regardless status particular user way particular user actually uses, expects expected use, product. product consumer product regardless whether product substantial commercial, industrial non-consumer uses, unless uses represent significant mode use product. ‚ÄúInstallation Information‚Äù User Product means methods, procedures, authorization keys, information required install execute modified versions covered work User Product modified version Corresponding Source. information must suffice ensure continued functioning modified object code case prevented interfered solely modification made. convey object code work section , , specifically use , User Product, conveying occurs part transaction right possession use User Product transferred recipient perpetuity fixed term (regardless transaction characterized), Corresponding Source conveyed section must accompanied Installation Information. requirement apply neither third party retains ability install modified object code User Product (example, work installed ROM). requirement provide Installation Information include requirement continue provide support service, warranty, updates work modified installed recipient, User Product modified installed. Access network may denied modification materially adversely affects operation network violates rules protocols communication across network. Corresponding Source conveyed, Installation Information provided, accord section must format publicly documented (implementation available public source code form), must require special password key unpacking, reading copying.","code":""},{"path":"/LICENSE.html","id":"id_7-additional-terms","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"7. Additional Terms","title":"GNU General Public License","text":"‚ÄúAdditional permissions‚Äù terms supplement terms License making exceptions one conditions. Additional permissions applicable entire Program shall treated though included License, extent valid applicable law. additional permissions apply part Program, part may used separately permissions, entire Program remains governed License without regard additional permissions. convey copy covered work, may option remove additional permissions copy, part . (Additional permissions may written require removal certain cases modify work.) may place additional permissions material, added covered work, can give appropriate copyright permission. Notwithstanding provision License, material add covered work, may (authorized copyright holders material) supplement terms License terms: ) Disclaiming warranty limiting liability differently terms sections 15 16 License; b) Requiring preservation specified reasonable legal notices author attributions material Appropriate Legal Notices displayed works containing ; c) Prohibiting misrepresentation origin material, requiring modified versions material marked reasonable ways different original version; d) Limiting use publicity purposes names licensors authors material; e) Declining grant rights trademark law use trade names, trademarks, service marks; f) Requiring indemnification licensors authors material anyone conveys material (modified versions ) contractual assumptions liability recipient, liability contractual assumptions directly impose licensors authors. non-permissive additional terms considered ‚Äúrestrictions‚Äù within meaning section 10. Program received , part , contains notice stating governed License along term restriction, may remove term. license document contains restriction permits relicensing conveying License, may add covered work material governed terms license document, provided restriction survive relicensing conveying. add terms covered work accord section, must place, relevant source files, statement additional terms apply files, notice indicating find applicable terms. Additional terms, permissive non-permissive, may stated form separately written license, stated exceptions; requirements apply either way.","code":""},{"path":"/LICENSE.html","id":"id_8-termination","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"8. Termination","title":"GNU General Public License","text":"may propagate modify covered work except expressly provided License. attempt otherwise propagate modify void, automatically terminate rights License (including patent licenses granted third paragraph section 11). However, cease violation License, license particular copyright holder reinstated () provisionally, unless copyright holder explicitly finally terminates license, (b) permanently, copyright holder fails notify violation reasonable means prior 60 days cessation. Moreover, license particular copyright holder reinstated permanently copyright holder notifies violation reasonable means, first time received notice violation License (work) copyright holder, cure violation prior 30 days receipt notice. Termination rights section terminate licenses parties received copies rights License. rights terminated permanently reinstated, qualify receive new licenses material section 10.","code":""},{"path":"/LICENSE.html","id":"id_9-acceptance-not-required-for-having-copies","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"9. Acceptance Not Required for Having Copies","title":"GNU General Public License","text":"required accept License order receive run copy Program. Ancillary propagation covered work occurring solely consequence using peer--peer transmission receive copy likewise require acceptance. However, nothing License grants permission propagate modify covered work. actions infringe copyright accept License. Therefore, modifying propagating covered work, indicate acceptance License .","code":""},{"path":"/LICENSE.html","id":"id_10-automatic-licensing-of-downstream-recipients","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"10. Automatic Licensing of Downstream Recipients","title":"GNU General Public License","text":"time convey covered work, recipient automatically receives license original licensors, run, modify propagate work, subject License. responsible enforcing compliance third parties License. ‚Äúentity transaction‚Äù transaction transferring control organization, substantially assets one, subdividing organization, merging organizations. propagation covered work results entity transaction, party transaction receives copy work also receives whatever licenses work party‚Äôs predecessor interest give previous paragraph, plus right possession Corresponding Source work predecessor interest, predecessor can get reasonable efforts. may impose restrictions exercise rights granted affirmed License. example, may impose license fee, royalty, charge exercise rights granted License, may initiate litigation (including cross-claim counterclaim lawsuit) alleging patent claim infringed making, using, selling, offering sale, importing Program portion .","code":""},{"path":"/LICENSE.html","id":"id_11-patents","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"11. Patents","title":"GNU General Public License","text":"‚Äúcontributor‚Äù copyright holder authorizes use License Program work Program based. work thus licensed called contributor‚Äôs ‚Äúcontributor version‚Äù. contributor‚Äôs ‚Äúessential patent claims‚Äù patent claims owned controlled contributor, whether already acquired hereafter acquired, infringed manner, permitted License, making, using, selling contributor version, include claims infringed consequence modification contributor version. purposes definition, ‚Äúcontrol‚Äù includes right grant patent sublicenses manner consistent requirements License. contributor grants non-exclusive, worldwide, royalty-free patent license contributor‚Äôs essential patent claims, make, use, sell, offer sale, import otherwise run, modify propagate contents contributor version. following three paragraphs, ‚Äúpatent license‚Äù express agreement commitment, however denominated, enforce patent (express permission practice patent covenant sue patent infringement). ‚Äúgrant‚Äù patent license party means make agreement commitment enforce patent party. convey covered work, knowingly relying patent license, Corresponding Source work available anyone copy, free charge terms License, publicly available network server readily accessible means, must either (1) cause Corresponding Source available, (2) arrange deprive benefit patent license particular work, (3) arrange, manner consistent requirements License, extend patent license downstream recipients. ‚ÄúKnowingly relying‚Äù means actual knowledge , patent license, conveying covered work country, recipient‚Äôs use covered work country, infringe one identifiable patents country reason believe valid. , pursuant connection single transaction arrangement, convey, propagate procuring conveyance , covered work, grant patent license parties receiving covered work authorizing use, propagate, modify convey specific copy covered work, patent license grant automatically extended recipients covered work works based . patent license ‚Äúdiscriminatory‚Äù include within scope coverage, prohibits exercise , conditioned non-exercise one rights specifically granted License. may convey covered work party arrangement third party business distributing software, make payment third party based extent activity conveying work, third party grants, parties receive covered work , discriminatory patent license () connection copies covered work conveyed (copies made copies), (b) primarily connection specific products compilations contain covered work, unless entered arrangement, patent license granted, prior 28 March 2007. Nothing License shall construed excluding limiting implied license defenses infringement may otherwise available applicable patent law.","code":""},{"path":"/LICENSE.html","id":"id_12-no-surrender-of-others-freedom","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"12. No Surrender of Others‚Äô Freedom","title":"GNU General Public License","text":"conditions imposed (whether court order, agreement otherwise) contradict conditions License, excuse conditions License. convey covered work satisfy simultaneously obligations License pertinent obligations, consequence may convey . example, agree terms obligate collect royalty conveying convey Program, way satisfy terms License refrain entirely conveying Program.","code":""},{"path":"/LICENSE.html","id":"id_13-use-with-the-gnu-affero-general-public-license","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"13. Use with the GNU Affero General Public License","title":"GNU General Public License","text":"Notwithstanding provision License, permission link combine covered work work licensed version 3 GNU Affero General Public License single combined work, convey resulting work. terms License continue apply part covered work, special requirements GNU Affero General Public License, section 13, concerning interaction network apply combination .","code":""},{"path":"/LICENSE.html","id":"id_14-revised-versions-of-this-license","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"14. Revised Versions of this License","title":"GNU General Public License","text":"Free Software Foundation may publish revised /new versions GNU General Public License time time. new versions similar spirit present version, may differ detail address new problems concerns. version given distinguishing version number. Program specifies certain numbered version GNU General Public License ‚Äúlater version‚Äù applies , option following terms conditions either numbered version later version published Free Software Foundation. Program specify version number GNU General Public License, may choose version ever published Free Software Foundation. Program specifies proxy can decide future versions GNU General Public License can used, proxy‚Äôs public statement acceptance version permanently authorizes choose version Program. Later license versions may give additional different permissions. However, additional obligations imposed author copyright holder result choosing follow later version.","code":""},{"path":"/LICENSE.html","id":"id_15-disclaimer-of-warranty","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"15. Disclaimer of Warranty","title":"GNU General Public License","text":"WARRANTY PROGRAM, EXTENT PERMITTED APPLICABLE LAW. EXCEPT OTHERWISE STATED WRITING COPYRIGHT HOLDERS /PARTIES PROVIDE PROGRAM ‚Äú‚Äù WITHOUT WARRANTY KIND, EITHER EXPRESSED IMPLIED, INCLUDING, LIMITED , IMPLIED WARRANTIES MERCHANTABILITY FITNESS PARTICULAR PURPOSE. ENTIRE RISK QUALITY PERFORMANCE PROGRAM . PROGRAM PROVE DEFECTIVE, ASSUME COST NECESSARY SERVICING, REPAIR CORRECTION.","code":""},{"path":"/LICENSE.html","id":"id_16-limitation-of-liability","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"16. Limitation of Liability","title":"GNU General Public License","text":"EVENT UNLESS REQUIRED APPLICABLE LAW AGREED WRITING COPYRIGHT HOLDER, PARTY MODIFIES /CONVEYS PROGRAM PERMITTED , LIABLE DAMAGES, INCLUDING GENERAL, SPECIAL, INCIDENTAL CONSEQUENTIAL DAMAGES ARISING USE INABILITY USE PROGRAM (INCLUDING LIMITED LOSS DATA DATA RENDERED INACCURATE LOSSES SUSTAINED THIRD PARTIES FAILURE PROGRAM OPERATE PROGRAMS), EVEN HOLDER PARTY ADVISED POSSIBILITY DAMAGES.","code":""},{"path":"/LICENSE.html","id":"id_17-interpretation-of-sections-15-and-16","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"17. Interpretation of Sections 15 and 16","title":"GNU General Public License","text":"disclaimer warranty limitation liability provided given local legal effect according terms, reviewing courts shall apply local law closely approximates absolute waiver civil liability connection Program, unless warranty assumption liability accompanies copy Program return fee. END TERMS CONDITIONS","code":""},{"path":"/LICENSE.html","id":"how-to-apply-these-terms-to-your-new-programs","dir":"","previous_headings":"","what":"How to Apply These Terms to Your New Programs","title":"GNU General Public License","text":"develop new program, want greatest possible use public, best way achieve make free software everyone can redistribute change terms. , attach following notices program. safest attach start source file effectively state exclusion warranty; file least ‚Äúcopyright‚Äù line pointer full notice found. Also add information contact electronic paper mail. program terminal interaction, make output short notice like starts interactive mode: hypothetical commands show w show c show appropriate parts General Public License. course, program‚Äôs commands might different; GUI interface, use ‚Äúbox‚Äù. also get employer (work programmer) school, , sign ‚Äúcopyright disclaimer‚Äù program, necessary. information , apply follow GNU GPL, see <http://www.gnu.org/licenses/>. GNU General Public License permit incorporating program proprietary programs. program subroutine library, may consider useful permit linking proprietary applications library. want , use GNU Lesser General Public License instead License. first, please read <http://www.gnu.org/philosophy/--lgpl.html>.","code":"<one line to give the program's name and a brief idea of what it does.> Copyright (C) <year>  <name of author>  This program is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program.  If not, see <http://www.gnu.org/licenses/>. <program>  Copyright (C) <year>  <name of author> This program comes with ABSOLUTELY NO WARRANTY; for details type 'show w'. This is free software, and you are welcome to redistribute it under certain conditions; type 'show c' for details."},{"path":"/articles/calibrate-simulation-parameters.html","id":"calibrating-the-genetic-effect-size","dir":"Articles","previous_headings":"","what":"Calibrating the Genetic Effect Size","title":"Calibrate simulation parameters","text":"genetic effect size parameter œÉŒ≤\\sigma_\\beta directly impacts distribution taxa heritabilities (explanations given Pety et al. (2025) ). gen_effect_calibration() function allows users evaluate different values œÉŒ≤\\sigma_\\beta influence distribution. practice, heritabilities taxa expected lie around 0.1, rarely exceeding 0.5 suggested Zang et al. (2022) .   Select effect sizes lead taxa heritability distributions consistent literature:  Based Zang et al. (2022) expectations, reasonable distribution taxa heritabilities appears correspond value œÉŒ≤*QTLo=0.3\\sigma_\\beta * \\sqrt {QTL_o} = 0.3 case D√©ru et al. (2020) dataset.","code":"data(Deru) ToyData <- Deru taxa_assign_g <- assign_taxa(founder_object = ToyData) effect_size_vector <- c(seq(0.1, 1, by = 0.1)) out_data <- gen_effect_calibration(founder_object = ToyData,                                    taxa_assign_g = taxa_assign_g,                                    correlation = 0.5,                                    effect.size = effect_size_vector,                                    plot = TRUE) #> Picking joint bandwidth of 0.036 density_peaks <- out_data %>%   group_by(effect.size) %>%   summarise(     peak = density(Heritability)$y[which.max(density(Heritability)$y)],     peak_x = density(Heritability)$x[which.max(density(Heritability)$y)]   )   out_data_filtered <- out_data %>% semi_join(density_peaks, by = \"effect.size\")  p2 <- ggplot(out_data_filtered, aes(x = Heritability, fill = as.factor(effect.size))) +   geom_density(alpha = 0.5, color = NA) +   geom_text(     data = density_peaks,     aes(x = peak_x, y = peak, label = as.factor(effect.size), color = as.factor(effect.size)),     inherit.aes = FALSE,     hjust = -0.1,     size = 3,     show.legend = FALSE   ) +   labs(     x = \"Taxa heritability\",     y = \"Density\",     fill = \"Genetic effect size\",     title = \"Taxa heritability density, noise 0.5\"   ) +   theme(     panel.background = element_rect(fill = \"white\"),     panel.grid.major = element_line(colour = \"#e3e3e3\"),     panel.grid.minor = element_line(colour = \"#e9e9e9\"),     axis.title = element_text(size = 8),     axis.text = element_text(size = 7),     plot.title = element_text(size = 7),     legend.position = \"right\"   ) +   scale_fill_paletteer_d(paste0(\"werpals\", \"::\", \"uyuni\")) +   scale_color_paletteer_d(paste0(\"werpals\", \"::\", \"uyuni\")) +   guides(color = \"none\")  p2 #ggplotly(p2) easier to navigate on this plot with ggplotly"},{"path":"/articles/calibrate-simulation-parameters.html","id":"calibrating-the-multinomial-sampling-size","dir":"Articles","previous_headings":"","what":"Calibrating the Multinomial Sampling Size","title":"Calibrate simulation parameters","text":"multinomial sampling size used simulate count data based relative abundances, specially selection based diversity. default value (10,000) richness_from_abundances_gen() function calibrated using Deru dataset reflects typical sequencing depths. counts drawn according multinomial low M(N,p)M(N,p) pp relative abundances vector NN sampling size. Let following formula M(10000,(pi,1,...,pi,nb))M(10000, (p_{,1}, ..., p_{,n_b})). parameter adapted dataset based observed sequencing depth distribution. Sequencing depths distribution:  suggest using median promote robustness potential outliers present dataset. example, median close 10,000, supporting default parameter value dataset.","code":"data(Deru) ToyData <- Deru sample_depth <- rowSums(ToyData$microbiome)  ggplot(data.frame(Depth = sample_depth), aes(x = Depth)) +   geom_histogram(bins = 120, alpha = 0.3, fill = \"#1f618d\", color = \"#1f618d\") +   labs(title = \"Sequencing depths distribution of the microbiome\",        x = \"Sequencing depth\",        y = \"Number of samples\") +      theme_minimal() +   theme(legend.title = element_blank()) summary(sample_depth) #>    Min. 1st Qu.  Median    Mean 3rd Qu.    Max.  #>    8288    9753    9830    9798    9880    9965"},{"path":"/articles/calibrate-simulation-parameters.html","id":"summary-of-parameter-calibration","dir":"Articles","previous_headings":"","what":"Summary of parameter calibration","title":"Calibrate simulation parameters","text":"vignette provides guidelines calibrating two parameters holo_simu() simulation framework based new dataset. two parameters can specified holo_simu() call, well : want reproduce figures article dataset, remember modify size_rmultinom parameter richness_from_abundances_gen() computing diversity.","code":"generations_simu <- holo_simu(founder_object = ToyData,                               h2 = 0.25,                               b2 = 0.25,                               n_ind = 500,                               n_clust = taxa_assign_g,                               effect.size = 0.3,                               size_rmultinom = 10000)"},{"path":[]},{"path":"/articles/generate-figures.html","id":"load-data","dir":"Articles","previous_headings":"","what":"Load data","title":"Generate figures","text":"data matrix loaded count matrix taxa (columns) across individuals (rows). toy dataset, subset D√©ru et al.¬†2020, 1845 species 780 individuals coming conventional diet. Genotypes encoded 0,1,2 reachable thanks ‚Äúpopulation‚Äù attribute.","code":"data(\"Deru\") founder_object <- Deru founder_object$microbiome[1:5,1:5] #>   OTU1 OTU2 OTU6793 OTU3 OTU4 #> 1   30  593       4  630  414 #> 2  254  275      62 1131  446 #> 3  181  487     164 1472  656 #> 4  469  665      45  640  328 #> 5  771  519      21  758  347 #MoBPS population structure, use get.geno() and generation index to extract genotypes genotypes <- founder_object$population %>%   get.geno(gen=1)  genotypes[1:5,1:5] #>      M1_1 M2_1 M3_1 M4_1 M5_1 #> SNP1    2    2    1    1    2 #> SNP2    1    1    1    1    1 #> SNP3    2    2    2    2    2 #> SNP4    2    2    2    2    2 #> SNP5    2    2    1    1    2"},{"path":"/articles/generate-figures.html","id":"simulation-reflects-structure-of-microbiome","dir":"Articles","previous_headings":"","what":"Simulation reflects structure of microbiome","title":"Generate figures","text":"section matches code Figure 3 paper.","code":""},{"path":"/articles/generate-figures.html","id":"produce-intra--and-inter-cluster-anticorrelations","dir":"Articles","previous_headings":"Simulation reflects structure of microbiome","what":"Produce intra- and inter-cluster (anti)correlations","title":"Generate figures","text":"Œ≤\\beta matrix, values overlapping QTL, ‚Äôre able induce correlations taxa. example, 4% taxa genetic control. pairwise correlation matrix taxa abundances represented . Taxa sorted based cluster belong . elements ‚Äôre able call holo_simu(). Œ≤\\beta matrix reachable metadata holo_simu() output. ‚Äôre able build Heatmap using ComplexHeatmap","code":"taxa_assign_g_small <- assign_taxa(founder_object,                                     taxa_g = 0.04)  # Output is the assignation of each taxa to a cluster, 0 corresponds to taxa that are not under genetic control taxa_assign_g_small[taxa_assign_g_small !=0 ] #>  [1] 1 1 1 2 1 1 2 1 3 4 3 4 3 2 2 2 4 3 2 5 2 2 2 4 3 3 2 3 4 3 3 1 6 6 1 6 4 4 #> [39] 6 1 5 5 1 5 4 4 1 5 3 3 4 2 6 4 6 5 5 4 6 6 6 2 3 5 1 5 5 5 5 5 6 6 4 4 4 5 #> [77] 4 3 6 #> Levels: 0 1 2 3 4 5 6 noise = 0.6 #noise of the microbiome effect.size = 0.3 #genetic effect size lambda = 0.5 #same weight for vertical and horizontal transmission dir = T #dirichlet sampling for ambient microbiome  generations_simu <- holo_simu(h2 = 0.25, #direct heritability                               b2 = 0.25, #microbiability                               founder_object = founder_object,                               n_clust = taxa_assign_g_small,                               n_ind = 500, #per generation                               verbose = F,                                noise.microbiome = noise,                               effect.size = effect.size,                               lambda = lambda,                               dir = dir,                               selection = F, #30% males and females sampled for next generation                               seed = 333) #Correlation intra-cluster for cluster under genetic control beta <- generations_simu$metadata$Beta_matrix$matrix[taxa_assign_g_small != 0,] cor_matrix <- cor(t(beta)) taxa_order <- taxa_assign_g_small[taxa_assign_g_small != 0] %>% order() cor_matrix <- cor_matrix[taxa_order,taxa_order] pal <- colorRampPalette(RColorBrewer::brewer.pal(5,\"Set1\"))(length(taxa_assign_g_small[taxa_assign_g_small != 0] %>% unique())) clus_col <- structure(pal, names = taxa_assign_g_small[taxa_assign_g_small != 0] %>% unique() %>% as.vector())  leftAnn = rowAnnotation(clust = taxa_assign_g_small[taxa_assign_g_small != 0] %>% sort(),                         col = list(clust = clus_col),                         show_annotation_name = F,                         annotation_legend_param = list(clust = list(title = \"Cluster ID\",title_gp = gpar(fontsize = 5, fontface = \"bold\"), labels_gp = gpar(fontsize = 5, fontface = 'bold')))) colAnn = HeatmapAnnotation(clust = taxa_assign_g_small[taxa_assign_g_small != 0] %>% sort(),                         col = list(clust = clus_col),                         show_annotation_name = F,                         show_legend = FALSE)  col_fun = colorRamp2(c(min(cor_matrix), 0, max(cor_matrix)), c(\"blue\", \"white\", \"red\"))  p1 <- grid.grabExpr(draw(Heatmap(cor_matrix,          cluster_rows = F,          cluster_columns = F,          show_row_names = F,          show_column_names = F,         left_annotation = leftAnn,         top_annotation = colAnn,         col = col_fun,         heatmap_legend_param = list(title = \"Correlation\", title_gp = gpar(fontsize = 5, fontface = \"bold\"), labels_gp = gpar(fontsize = 5, fontface = 'bold')))))  plot_grid(p1)"},{"path":"/articles/generate-figures.html","id":"modulate-relative-importance-of-vertical-and-horizontal-transmission","dir":"Articles","previous_headings":"Simulation reflects structure of microbiome","what":"Modulate relative importance of vertical and horizontal transmission","title":"Generate figures","text":"composition microbiota individuals given equation : Œªùêåd()(t‚àí1)+(1‚àíŒª)ùêåa()(t)\\lambda \\boldsymbol{M}^{(t-1)}_{d()} + (1 - \\lambda) \\boldsymbol{M}^{(t)}_{()}. Given , Œª=0\\lambda = 0 corresponds vertical transmission. ‚Äôre looking correlations offspring Œ±-diversity (G2) mother (purple), father (orange) ambient microbiota (green) increasing values Œª. perform taxa assignation small study. following function can call parallel different scnarios test. want parallelize code, use plan(multisession). useful information simulations microbiomes, pedigree ambient microbiome extracted generation. ‚Äôre focusing G2 .","code":"set.seed(484)  #Change n_it to increase the accuracy of the function, n_it = 10 used in the article n_it = 1 seed_value <- sample(c(100:9999),n_it)  params_df_it <- tibble::tibble(lambda = c(0,0.5,1)) %>%   crossing(tibble(seed = seed_value)) %>%    mutate(sim_ID = row_number(), .before = \"lambda\") taxa_assign_g <- assign_taxa(founder_object) noise = 0.1 effect.size = 0.1 center_bg = T dir = T  #Boxplot lambda vs diversity correlation with offspring    run_simulation_lambda <- function(i, it) {       generations_simu <- holo_simu(h2 = 0.25,                                     b2 = 0.25,                                     founder_object = founder_object,                                     n_clust = taxa_assign_g,                                     n_ind = 500,                                     verbose = F,                                     noise.microbiome = noise,                                     effect.size = effect.size,                                     lambda = as.numeric(params_df_it[i,\"lambda\"]),                                     dir = dir,                                     selection = F,                                     seed = as.numeric(params_df_it[i,\"seed\"]))              #Richness of G2 offsprings       current_div <- generations_simu$G2$microbiome %>%          richness_from_abundances_gen(size_rmultinom = generations_simu$parameters$size_rmultinom)              #Richness of offpsring's fathers       previous_s_div <- sapply(generations_simu$G2$pedigree[,\"father\"],                                function(x){generations_simu$G1$microbiome[,x]}) %>%          richness_from_abundances_gen(size_rmultinom = generations_simu$parameters$size_rmultinom)              #Richness of offpsring's mothers       previous_d_div <- sapply(generations_simu$G2$pedigree[,\"mother\"],                                function(x){generations_simu$G1$microbiome[,x]}) %>%          richness_from_abundances_gen(size_rmultinom = generations_simu$parameters$size_rmultinom)              #Richness of ambient microbiome       ambient_div <- generations_simu$G2$mean_microbiome %>%          richness_from_abundances_gen(size_rmultinom = generations_simu$parameters$size_rmultinom)                     tibble(lambda = list(as.numeric(params_df_it[i,\"lambda\"])),              Mother = list(cor(current_div$Shannon,previous_d_div$Shannon)),              Father = list(cor(current_div$Shannon,previous_s_div$Shannon)),              Ambient = list(cor(current_div$Shannon,ambient_div$Shannon))       )   } plan(sequential) results <- future_map_dfr(   seq_len(nrow(params_df_it)),   function(i) {     map_dfr(seq_len(n_it), ~ run_simulation_lambda(i, .x))   } ) plan(sequential) long_cor_gen <- results %>%    mutate(lambda = unlist(lambda),          Mother = unlist(Mother),          Father = unlist(Father),          Ambient = unlist(Ambient)) %>%   pivot_longer(c(\"Mother\",\"Father\",\"Ambient\"),                names_to = \"cor_type\",                values_to = \"value\") lambda_label <- cbind(x = c(0,0.5,1),                       y = c(0.8,0.2,0.8),                       label = c(\"Ambient\",\"Father\",\"Mother\")) %>% as.data.frame() lambda_label$y <- as.numeric(lambda_label$y)  p3 <- long_cor_gen %>% summarise(value = mean(value), .by = c(lambda, cor_type)) |> ggplot(aes(x=as.factor(lambda),y=value,col=cor_type, group = cor_type)) +   geom_line() +   geom_point( alpha=0.8)  +   geom_text_repel(data = lambda_label,                   aes(x = x, y = y, label = label, color = label, group = NULL),         direction = \"y\",         show.legend = FALSE) +   theme(legend.key.size = unit(0.25, 'cm')) +   ylab(\"Correlation value\") +   xlab(\"Lambda\") +   labs(col = \"Parents\") +   guides(shape = \"none\") +   ylim(-0.2,1) +   scale_y_continuous(     breaks = seq(0,1,0.25),     labels = seq(0,1,0.25)   ) +   scale_color_brewer(palette = \"Dark2\")  p3"},{"path":"/articles/generate-figures.html","id":"achieve-a-target-distribution-of-taxa-heritabilities","dir":"Articles","previous_headings":"Simulation reflects structure of microbiome","what":"Achieve a target distribution of taxa heritabilities","title":"Generate figures","text":"function calibrate_gen_effect() intended guide user choosing appropriate effect size achieve target distribution taxa heritabilities. Build-plots function ‚Äôve used output function order make density plot distribution taxa heritability increasing genetic effect sizes (œÉŒ≤√óQTLo\\sigma_{\\beta}\\times\\sqrt{\\text{QTL}_\\text{o}}), shown curve.","code":"out_data <- gen_effect_calibration(founder_object = founder_object,                                    taxa_assign_g = taxa_assign_g,                                    correlation = 0.5,                                    effect.size = c(0.3,0.6,1),                                    plot = F) # Calculate density peaks density_peaks <- out_data %>%   group_by(effect.size) %>%   summarise(     peak = density(Heritability)$y[which.max(density(Heritability)$y)],     peak_x = density(Heritability)$x[which.max(density(Heritability)$y)]   )    p2 <- out_data %>% ggplot(aes(x=Heritability,fill=as.factor(effect.size), label = as.factor(effect.size))) +       geom_density(alpha=0.8, color = NA)+       geom_text_repel(         data = density_peaks,         aes(x = peak_x, y = peak, label = effect.size, color = as.factor(effect.size)),         nudge_x = 0.02,         nudge_y = 0.3,         direction = \"y\",         show.legend = FALSE) +       labs(x = \"Taxa heritability\",            y = \"Density\",            fill = \"Genetic effect size\")+       theme(panel.background = element_rect(fill=\"white\"),             panel.grid.major = element_line(colour=\"#e3e3e3\"),             panel.grid.minor = element_line(colour=\"#e9e9e9\"),             axis.title = element_text(size = 8),             axis.text = element_text(size=7),             plot.title = element_text(size=7),             legend.position = \"none\") +     scale_fill_manual(values = c(\"#00AFBB\", \"#E7B800\", \"#FC4E07\")) +     scale_color_manual(values = c(\"#00AFBB\", \"#E7B800\", \"#FC4E07\"))  p2"},{"path":"/articles/generate-figures.html","id":"alpha-diversity-remains-stable-across-generations","dir":"Articles","previous_headings":"Simulation reflects structure of microbiome","what":"Alpha-diversity remains stable across generations","title":"Generate figures","text":"neutral framework, without selection environmental effect, expect Œ±\\alpha-diversity stable across generations. holo_simu() output, relative abundances taxa, Œ±\\alpha-diversity indexes thanks multinomial sampling richness_from_abundances_gen() function.","code":"h2 = 0.25 b2 = 0.25 generations_simu <- holo_simu(h2 = h2,                               b2 = b2,                               founder_object = founder_object,                               n_clust = taxa_assign_g,                               n_ind = 500,                               verbose = F,                               noise.microbiome = noise,                               effect.size = effect.size,                               lambda = 0.5,                               dir = dir,                               selection = F,                               seed = 8082) diversities_microbiomes <- generations_simu[-c(1,2)] %>% map(get_microbiomes) %>%   map(richness_from_abundances_gen, size_rmultinom = generations_simu$parameters$size_rmultinom) |>   bind_rows(.id = \"Generation\")    p4 <- ggplot(diversities_microbiomes,aes(x=Shannon,y=Generation,fill=Generation)) +         geom_density_ridges(alpha=0.8) +          theme(aspect.ratio = 1.5)+   scale_fill_manual(values = rev(greens_pal))    p4 ggsave(\"../man/figures/ridges_shannon.png\", p4, width = 9, height = 6)"},{"path":"/articles/generate-figures.html","id":"introduction-of-transient-perturbations-of-the-microbiota","dir":"Articles","previous_headings":"","what":"Introduction of transient perturbations of the microbiota","title":"Generate figures","text":"breeding selection programs, essential account fixed environmental effects, given strong role modulating individual‚Äôs phenotype. therefore important verify simulated transgenerational hologenomic data can correctly integrate factors variety plausible scenarios, short-term treatments long-term diet effects. build modulation, user build outside main function Œ∏X\\theta X product choose precisely values effect size given environmental effect. Dimensions product match founder_object$microbiome ones. evaluate simulation part ‚Äôve computed multidimensional scaling (MDS) microbial abundance data using Bray-Curtis distances ridges plot Shannon index values. section matches code Figure 4 paper.","code":""},{"path":"/articles/generate-figures.html","id":"sporadic-environmental-effect","dir":"Articles","previous_headings":"Introduction of transient perturbations of the microbiota","what":"Sporadic environmental effect","title":"Generate figures","text":"Half individuals G1 subject sporadic antibiotic treatment affects taxa.","code":"#Construction of environmental effect before simulating the population h2 = 0.25 b2 = 0.25 noise = 0.6 effect.size = 0.3 dir= T n_ind = 500 lambda = 0.5  set.seed(42) antibio <- rep(0, n_ind) antibio_ind <- sample(1:n_ind, 250) #selecting index of individuals antibio[antibio_ind] <- 1  X <- matrix(antibio, ncol = n_ind, nrow = 1)  theta <- rnorm(ncol(founder_object$microbiome),mean = 0, sd = 5) #sampling strong antibiotics effect theta <- ifelse(theta > 0, -theta, theta) %>% matrix(ncol = 1, nrow = ncol(founder_object$microbiome)) #only negative values for all taxa  thetaX <- theta %*% X generations_simu_env <- holo_simu(h2 = h2,                                   b2 = b2,                                   founder_object = founder_object,                                   n_clust = taxa_assign_g,                                   n_ind = n_ind,                                   verbose = F,                                   noise.microbiome = noise,                                   effect.size = effect.size,                                   lambda = lambda,                                   dir = dir,                                   selection = F,                                   seed = 30,                                   thetaX = thetaX,                                   env_gen = c(T,F,F,F,F)) #on the five generations asked, we apply thetaX only on G1, not considering G0"},{"path":"/articles/generate-figures.html","id":"diversity-on-antibiotic-effect","dir":"Articles","previous_headings":"Introduction of transient perturbations of the microbiota > Sporadic environmental effect","what":"Diversity on antibiotic effect","title":"Generate figures","text":"Call get_microbiomes() richness_from_abundances_gen() extract useful metrics.","code":"diversities_microbiomes <- generations_simu[-c(1,2)] %>% map(get_microbiomes) %>%   map(richness_from_abundances_gen, size_rmultinom = generations_simu$parameters$size_rmultinom) |>   bind_rows(.id = \"Generation\")    p1 <- diversities_microbiomes %>% filter(!Generation %in% c(\"G4\",\"G5\")) %>%     ggplot(aes(x=Shannon,y=Generation,fill=Generation)) +     geom_density_ridges(alpha=0.8) +      theme(aspect.ratio = 1.5)+     scale_fill_manual(values = rev(greens_pal)[1:4])      p1"},{"path":"/articles/generate-figures.html","id":"mds-on-antibiotic-effect","dir":"Articles","previous_headings":"Introduction of transient perturbations of the microbiota > Sporadic environmental effect","what":"MDS on antibiotic effect","title":"Generate figures","text":"Call vegan package compute Bray Curtis distance matrix. Call phyloseq package manipulate efficiently compute MDS ordinate() function.","code":"microbiomes_all <- generations_simu_env[c(3,4,5,6)] %>% map(get_microbiomes, transpose = T, CLR = F) |> bind_rows(.id = \"Generation\")                            antibio_vec <- rep(0, nrow(microbiomes_all)) id_antibio_ind <- rownames(microbiomes_all)[which(microbiomes_all$Generation == \"G1\")] %in% colnames((generations_simu_env$G1$microbiome))[which(X != 0)] antibio_vec[which(microbiomes_all$Generation == \"G1\")[id_antibio_ind]] <- 1 metadata <- cbind(Generation = microbiomes_all$Generation, ID = rownames(microbiomes_all), antibio = antibio_vec) |> as.data.frame() rownames(metadata) <- metadata$ID dist_mat <- vegan::vegdist(x = microbiomes_all[-1],                  method = \"bray\") physeq <- phyloseq(   otu_table(t(microbiomes_all[,-1]), taxa_are_rows = TRUE),   sample_data(metadata))  ord <- ordinate(physeq, method = \"MDS\", distance = dist_mat)  DF <- plot_ordination(physeq, ord, justDF = T) p2 <- ggplot(data = DF, aes(x=DF[,1], y=DF[,2], color = antibio, shape=antibio)) +      labs(x = \"Axis 1\",          y = \"Axis 2\") +   geom_point(alpha = 0.8) +    theme(legend.key.size = unit(0.25, 'cm'),         strip.text = element_text(color = \"white\", face = \"bold\")) +   facet_wrap2(~Generation, nrow = 2, ncol = 2, strip = strip_themed(background_x = elem_list_rect(fill = rev(greens_pal)[1:4])))  p2"},{"path":"/articles/generate-figures.html","id":"sustained-environmental-effet","dir":"Articles","previous_headings":"Introduction of transient perturbations of the microbiota","what":"Sustained environmental effet","title":"Generate figures","text":"Starting G1, half individuals generation (blue triangles) subject diet favoring two clusters taxa.","code":"h2 = 0.25 b2 = 0.25 noise = 0.6 effect.size = 0.3 dir= T center_bg = T n_ind = 500 lambda = 0.5  set.seed(56) # Xi <- small portions of individuals diet <- rep(0, n_ind) diet_ind <- sample(1:n_ind, 250) diet[diet_ind] <- 1  X <- matrix(diet, ncol = n_ind, nrow = 1)  theta <- rep(0, length(taxa_assign_g)) cluster_diet <- table(taxa_assign_g)[table(taxa_assign_g) > 10 & table(taxa_assign_g) < 30] %>% sample(3) %>% names() %>% as.numeric() #sample of clusters modulated by diet theta[taxa_assign_g %in% cluster_diet] <- rnorm(sum(taxa_assign_g %in% cluster_diet ),mean = 0, sd = 2) theta <- ifelse(theta < 0, -theta, theta) %>% matrix(ncol = 1, nrow = length(taxa_assign_g))#Only positive values for all taxa  thetaX <- theta %*% X generations_simu_env <- holo_simu(h2 = h2,                               b2 = b2,                               founder_object = founder_object,                               n_clust = taxa_assign_g,                               n_ind = n_ind,                               verbose = F,                               noise.microbiome = noise,                               effect.size = effect.size,                               lambda = lambda,                               dir = dir,                               selection = F,                               seed = 3042,                               thetaX = thetaX,                               env_gen = c(T,T,T,T,T)) #Applied on all generations"},{"path":"/articles/generate-figures.html","id":"diversity-on-diet-effect","dir":"Articles","previous_headings":"Introduction of transient perturbations of the microbiota > Sustained environmental effet","what":"Diversity on diet effect","title":"Generate figures","text":"","code":"diversities_microbiomes <- generations_simu_env[c(3,4,5,6)] %>% map(get_microbiomes) %>%   map(richness_from_abundances_gen, size_rmultinom = generations_simu$parameters$size_rmultinom) |>    bind_rows(.id = \"Generation\")    p4 <- ggplot(diversities_microbiomes,aes(x=Shannon,y=Generation,fill=Generation)) +         geom_density_ridges(alpha=0.8) +          theme(aspect.ratio = 1.5)+         scale_fill_manual(values = rev(greens_pal)[1:4]) p4"},{"path":"/articles/generate-figures.html","id":"mds-on-diet-effect","dir":"Articles","previous_headings":"Introduction of transient perturbations of the microbiota > Sustained environmental effet","what":"MDS on diet effect","title":"Generate figures","text":"","code":"#Post-processing of the data microbiomes_all <- generations_simu_env[c(3,4,5,6)] %>% map(get_microbiomes, transpose = T, CLR = F) |> bind_rows(.id = \"Generation\")  diet_vec <- rep(0, nrow(microbiomes_all)) diet_vec[which(microbiomes_all$Generation == \"G1\")[diet_ind]] <- 1 diet_vec[which(microbiomes_all$Generation == \"G2\")[diet_ind]] <- 1 diet_vec[which(microbiomes_all$Generation == \"G3\")[diet_ind]] <- 1 diet_vec[which(microbiomes_all$Generation == \"G4\")[diet_ind]] <- 1 diet_vec[which(microbiomes_all$Generation == \"G5\")[diet_ind]] <- 1  metadata <- cbind(Generation = microbiomes_all$Generation, ID = rownames(microbiomes_all), diet = diet_vec) |> as.data.frame() rownames(metadata) <- metadata$ID dist_mat <- vegan::vegdist(x = microbiomes_all[-1],                  method = \"bray\") physeq <- phyloseq(   otu_table(t(microbiomes_all[,-1]), taxa_are_rows = TRUE),   sample_data(metadata))  ord <- ordinate(physeq, method = \"MDS\", distance = dist_mat) DF <- plot_ordination(physeq, ord, justDF = T) p3 <- ggplot(data = DF, aes(x=DF[,1], y=DF[,2], color = diet, shape=diet)) +      labs(x = \"Axis 1\",          y = \"Axis 2\") +   geom_point(alpha = 0.8) +    theme(legend.key.size = unit(0.25, 'cm'),         strip.text = element_text(color = \"white\", face = \"bold\")) +   facet_wrap2(~Generation, nrow = 2, ncol = 2, strip = strip_themed(background_x = elem_list_rect(fill = rev(greens_pal)[1:4]))) +   scale_fill_manual(values = rev(greens_pal)[1:4]) p3"},{"path":"/articles/generate-figures.html","id":"fine-selection-of-direct-heritability-microbiability-and-selection-schemes","dir":"Articles","previous_headings":"","what":"Fine selection of direct heritability, microbiability and selection schemes","title":"Generate figures","text":"absence selection, want verify target values reached maintained across generations observe trends phenotypic improvement function four different selection strategies. computation plots section performed time, barplot subset facet grid. section matches code Figure 5 paper.","code":""},{"path":"/articles/generate-figures.html","id":"target-values-of-direct-heritability-and-microbiability-are-reached-and-maintained","dir":"Articles","previous_headings":"Fine selection of direct heritability, microbiability and selection schemes","what":"Target values of direct heritability and microbiability are reached and maintained","title":"Generate figures","text":"want parallelize code, use plan(multisession).","code":"# n_it = 50 was used to generate the figures of the article n_it = 1 set.seed(42) vec_seed <- sample(100:10000,n_it) noise = 0.6 effect.size = 0.3 lambda = 0.1 dir = T    #For the exemple, not all values were computed, you can uncomment all the lines to obtain the complete figure. params_df_it <- tibble::tribble(   ~h2,  ~b2, #  0.05, 0.05, #  0.25, 0.05, #  0.4,  0.05,  # 0.05, 0.25,   0.25, 0.25,   0.4,  0.25, #  0.05, 0.4,  0.25, 0.4,   0.4,  0.4   ) |> crossing(tibble(`Selection Type` = c(\"GB\", \"G\", \"B\", \"None\")),tibble(seed = vec_seed)) |>    mutate(sim_ID = row_number(), .before = \"h2\") params_df <- tibble::tribble(   ~h2,  ~b2,  # 0.05, 0.05,  # 0.25, 0.05, #  0.4,  0.05,  # 0.05, 0.25,   0.25, 0.25,   0.4,  0.25, #  0.05, 0.4,   0.25, 0.4,   0.4,  0.4 ) |>    crossing(tibble(`Selection Type` = c(\"GB\", \"G\", \"B\", \"Random\"))) |>    mutate(sim_ID = row_number(), .before = \"h2\") run_simulation <- function(i, it) {   start_time_it <- Sys.time()      ram_result <- peakRAM({     taxa_assign_g <- assign_taxa(founder_object)     selection = if (params_df$`Selection Type`[i] == \"Random\") FALSE else TRUE     generations_simu <- holo_simu(       h2 = params_df$h2[i],       b2 = params_df$b2[i],       founder_object = founder_object,       n_clust = taxa_assign_g,       n_ind = 500,       verbose = FALSE,       noise.microbiome = noise,       effect.size = effect.size,       lambda = lambda,       dir = dir,       selection = selection,       size_selection_F = if (selection == \"FALSE\") NULL else 0.3,       size_selection_M = if (selection == \"FALSE\") NULL else 0.3,       selection_type = if (params_df$`Selection Type`[i] == \"Random\") NULL else params_df$`Selection Type`[i],       seed = vec_seed[it]     )   })      gc() #clean memory      phenotypes_all <- generations_simu[-c(1,2)] %>% map(get_phenotypes) |> bind_rows(.id = \"Generation\")      tibble(mean_phenotypes = list(generations_simu[-c(1,2)] %>%                                    map(get_mean_phenotypes)),          metric_values = list(phenotypes_all %>%                                  group_by(Generation) %>%                                  summarise(h2 = var(gq)/var(y),                                            b2 = var(gb)/var(y),                                            e2 = 1 - var(gq)/var(y) - var(gb)/var(y)))   ) } plan(sequential) results <- future_map_dfr(   seq_len(nrow(params_df)),   function(i) {     map_dfr(seq_len(n_it), ~ run_simulation(i, .x))   } ) plan(sequential) metrics_values <- results %>%    bind_cols(params_df_it) %>%    filter(h2 == 0.25,b2 == 0.25) %>% #for barplot, gather only results for h2 = b2 = 0.25   select(metric_values) %>%    unnest_wider(metric_values) %>%    unnest_longer(c(Generation,h2,b2,e2)) %>%    group_by(Generation) %>%    summarize(h2 = mean(h2), b2 = mean(b2), e2=mean(e2)) %>%    pivot_longer(cols = c(h2, b2, e2), names_to = \"Metric\", values_to = \"Value\")  metrics_values$Metric <- factor(metrics_values$Metric, levels = c(\"e2\",\"b2\",\"h2\")) colours <- setNames(c(\"#ce0104\", \"#0237AE\", \"#808080\"),                      c(\"b2\", \"h2\", \"e2\"))  p2 <- metrics_values |> ggplot(aes(x=Generation, y = Value, fill = Metric))+   geom_bar(stat = \"identity\") +    ylab(\"Value\") +   theme(axis.text.y = element_text(vjust = seq(0, 1, length.out = 5)))+   geom_hline(yintercept = 0.25, col=\"white\", linetype = 2) +    annotate(\"text\", x = 3, y= 0.125, label=expression(bold(h[d]^2)), color = \"white\", size = 4) +    geom_hline(yintercept = 0.5, col=\"white\", linetype = 2) +    annotate(\"text\", x = 3, y= 0.375, label=expression(bold(b^2)), color = \"white\", size = 4) +    annotate(\"text\", x = 3, y= 0.75, label=expression(bold(e^2)), color = \"white\", size = 4) +    scale_y_continuous(expand = expansion(0, 0)) +    scale_fill_manual(values = colours) p2"},{"path":"/articles/generate-figures.html","id":"mean-phenotype-change-across-generations-according-to-selection-strategy","dir":"Articles","previous_headings":"Fine selection of direct heritability, microbiability and selection schemes","what":"Mean phenotype change across generations according to selection strategy","title":"Generate figures","text":"selection criteria : - Red line = Selection microbiota breeding values, - Blue line = Selection direct breeding values, - Purple line = Selection total breeding values, - Black line = Random selection","code":"mean_phenotypes <- results %>%    select(mean_phenotypes) %>%    bind_cols(params_df_it) %>%    unnest_wider(mean_phenotypes)  phenotypes_longer <- mean_phenotypes %>%    pivot_longer(cols = matches(\"^G\"), values_to = \"Y mean\", names_to = \"Generation\") %>%    summarise(\"Y sd\"   = sd(`Y mean`),              \"Y mean\" = mean(`Y mean`),             .by = c(`Selection Type`, Generation, h2, b2)) |>    mutate(\"Y mean\" = `Y mean` - `Y mean`[Generation == \"G0\"], .by = c(`Selection Type`, h2, b2))  phenotypes_longer$`Selection Type` <- ifelse(phenotypes_longer$`Selection Type` == \"GB\",\"TBV\", phenotypes_longer$`Selection Type`)  colours <- c(   B = \"#ce0104\",    G = \"#0237AE\",    TBV = \"#8123d9\",    None = \"black\" )  custom_labeller <- labeller(   b2 = as_labeller(function(x) paste0(\"b^2 == \", x), label_parsed),   h2 = as_labeller(function(x) paste0(\"h[d]^2 == \", x), label_parsed) )  labels <- phenotypes_longer |>    filter(h2 == 0.25, b2 == 0.25, Generation == \"G5\") |>    mutate(     label = recode(`Selection Type`,                    B = \"BV[m]\",                    G = \"BV[d]\",                    TBV = \"BV[t]\",                    None = \"Random\")) p1 <- phenotypes_longer |>    ggplot(aes(x = Generation, y = `Y mean`, group = `Selection Type`, color = `Selection Type`)) +    geom_point(size = 0.5) +    geom_line(alpha = 0.5)  +   geom_smooth(method = \"lm\", se = TRUE, linetype = 0, aes(fill = `Selection Type`), alpha = 0.2)+   geom_text_repel(data = labels,              aes(label = label), parse = T, hjust = -1, vjust = -0.8, direction = \"y\", segment.color = \"grey80\") +    labs(y = \"Mean phenotype change\") +   theme(panel.grid.major = element_line(colour=\"#e3e3e3\"),         panel.grid.minor.y = element_blank(),         panel.grid.major.x = element_blank(),          panel.grid.minor.x = element_blank(),          strip.text = element_text(size=12))  +   facet_grid(rows = vars(h2),               cols = vars(b2),               drop = TRUE,               labeller = custom_labeller,              switch = \"y\") +   scale_y_continuous(position = \"right\") +   scale_color_manual(values = colours) +   scale_fill_manual(values = colours) +   coord_cartesian(clip = \"off\") p1"},{"path":"/articles/generate-figures.html","id":"selection-index-based-on-a-combination-of-trait-and-diversity-metrics","dir":"Articles","previous_headings":"","what":"Selection index based on a combination of trait and diversity metrics","title":"Generate figures","text":"first demonstration usefulness RITHMS, consider practical case study complex breeding program multi-trait objective: maximizing phenotypic change perserving microbial Œ±\\alpha-diversity. section matches code Figure 6 paper. iteration, look diversity phenotype values. want parallelize code, use plan(multisession). look differences two traits base population last generation generation.","code":"#n_it = 25 was used to generate the figure of the article n_it = 1 set.seed(40) vec_seed <- sample(100:10000,n_it) params_df <- tibble::tribble(    ~div,  ~TBV,    0,    1,    1,    0,    0.5, 0.5,    0.8, 0.2,    0.2, 0.8,    0.7, 0.3,    0.3, 0.7,    0.4, 0.6,    0.6, 0.4,    0.1, 0.9,    0.9, 0.1   ) |> crossing(tibble(seed = vec_seed)) |>    mutate(sim_ID = row_number(), .before = \"div\") %>%    mutate(concatenated = glue(\"({div},{TBV})\"))  noise = 0.6 effect.size = 0.3 lambda = 0.5 run_simulation_study <- function(i, it) {    set.seed(as.numeric(params_df[i,4]))   taxa_assign_g <- assign_taxa(founder_object)      generations_simu <- holo_simu(h2 = 0.25,                                 b2 = 0.25,                                 founder_object = founder_object,                                 n_clust = taxa_assign_g,                                 n_ind = 500,                                 verbose = F,                                 noise.microbiome = noise,                                 effect.size = effect.size,                                 lambda = lambda,                                 selection = T,                                 dir = T,                                 size_selection_F = 0.3,                                 size_selection_M = 0.3,                                 selection_type = \"div.GB\",                                 w.param = c(as.numeric(params_df[i,2]), as.numeric(params_df[i,3])),                                 seed = as.numeric(params_df[i,4]))      tibble(mean_phenotypes_y = list(generations_simu[-c(1,2)] %>%                                      map(get_mean_phenotypes) %>%                                      bind_rows(.id = \"Generation\")),          diversities_microbiomes = list(generations_simu[-c(1,2)] %>%                                           map(get_microbiomes) %>%                                            map(richness_from_abundances_gen, size_rmultinom = generations_simu$parameters$size_rmultinom) |>                                            map(get_mean_diversity) %>%                                            bind_rows(.id = \"Generation\"))          )    } plan(sequential) results <- future_map_dfr(   seq_len(nrow(params_df)),   function(i) {     map_dfr(seq_len(n_it), ~ run_simulation_study(i, .x))   } ) plan(sequential) mean_phenotypes_y <- results$mean_phenotypes_y %>% bind_rows() diversities_microbiomes <- results$diversities_microbiomes %>% bind_rows() diff_y <- mean_phenotypes_y$G5 - mean_phenotypes_y$G0 diff_div <- diversities_microbiomes$G5 - diversities_microbiomes$G0  diff_data <- tibble(diff_y = diff_y,                     diff_div = diff_div,                     category = params_df$concatenated)  diff_data_concat <- diff_data %>% summarise(mean_div = mean(diff_div),                                              mean_y = mean(diff_y),                                              sd_div = (1.96 * sd(diff_div)/sqrt(n())),                                             sd_y = (1.96 * sd(diff_y)/sqrt(n())),                                             .by = c(category)) p <- diff_data %>%   mutate(w = str_remove_all(category, \"\\\\(|,.*\") |> as.numeric()) |>    ggplot(aes(y = diff_y, x = diff_div,               colour = w              )) +   geom_point(alpha = 0.4, shape = 20, size = 3) +   geom_point(data = diff_data_concat |> mutate(w = str_remove_all(category, \"\\\\(|,.*\") |> as.numeric()),               aes(y = mean_y, x = mean_div),               shape = 15, size = 5) +   geom_line(data = diff_data_concat |>  mutate(w = str_remove_all(category, \"\\\\(|,.*\") |> as.numeric()),              aes(y = mean_y, x = mean_div, group = 1), show.legend = FALSE) +   geom_vline(xintercept = 0, linetype = 2, color = \"darkgrey\") +   geom_hline(yintercept = 0, linetype = 2, color = \"darkgrey\") +    theme(legend.key.size = unit(0.3, 'cm'),     legend.title = element_text(size = 12, face = \"bold\"),      legend.text = element_text(size = 10),     legend.position = \"inside\",     legend.position.inside = c(0.49, 0.02),     legend.justification.inside = c(0.5, 0),      legend.direction = \"horizontal\",     legend.box = \"horizontal\",   ) +   labs(     y = \"Mean phenotype change (over 5 generations)\",     x = \"Microbial diversity change (over 5 generations)\",     colour = expression(w[div])   ) +    scale_color_viridis_c(option = \"D\",                          breaks = seq(0,1,0.1),                         name = expression(w[div]),                         labels = seq(0,1,0.1)) +   coord_cartesian(clip = \"off\") +   theme(legend.key.width = unit(25, \"mm\"),         legend.background = element_rect(fill = \"transparent\")) +   NULL  p"},{"path":"/articles/generate-figures.html","id":"future-work","dir":"Articles","previous_headings":"","what":"Future work","title":"Generate figures","text":"interesting extend RITHMS model : () account microbial interactions non-diagonal covariance matrix noise component œÉm\\sigma_{m} taxa abundances, (ii) allow inclusion complex environmental effects, (iii) allow use semi-complete, rather fully paired, genomic microbiota data create base population, enable RITHMS simulations calibrated datasets samples lack genomic microbiota data, (iv) use RITHMS alternative hologenomic datasets, notably variety species experimental designs, additional use cases evaluation complex breeding schemes. ideas collaboration relating package, feel free contact : solene.pety@inrae.fr","code":""},{"path":"/articles/import-data.html","id":"about-accepted-formats","dir":"Articles","previous_headings":"","what":"About accepted formats","title":"Import Data","text":"MoBPS package natively accepts two file formats generate starting population creating.diploid() function: PED/MAP format VCF. Thus, possible start simulation kind format, just specify type file_type argument read_input_data() function. Microbiotic data expected form count table, OTUs columns individuals rows. (column dedicated individual identifiers required). data filtered according prevalence threshold thanks threshold argument read_input_data().","code":"# Create founder object from PED/MAP set founder_object <- read_input_data(\"path/to/microbiome.txt\", \"path/to/pedmap/'prefix'\", biome_id_column = \"sample_id\", file_type = \"pedmap\")  #Create founder object from VCF founder_object <- read_input_data(\"path/to/microbiome.txt\", \"path/to/vcf/'prefix'\", biome_id_column = \"sample_id\", file_type = \"vcf\")"},{"path":"/articles/import-data.html","id":"import-simple-genotype-tables","dir":"Articles","previous_headings":"","what":"Import simple genotype tables","title":"Import Data","text":"possible provide RITHMS simple genotype matrix encoded 0,1,2 format, prior file transformation, detail . VCF file can written specifying output_type output_path arguments. , can continue classical import.","code":"n_ind <- 50 n_snp <- 50  # Create a little genotype matrix set.seed(123) geno_matrix <- matrix(sample(0:2, size = n_ind*n_snp, replace = TRUE),                       nrow = n_snp, ncol = n_ind)  # Transform genotype matrix into VCF vcf <- transform_geno_into_vcf(geno_matrix, output_type = \"dataframe\", output_path = \"./output/path/file.vcf\") head(vcf[1:3,1:7]) #Create founder object from VCF founder_object <- read_input_data(\"path/to/microbiome.txt\", \"path/to/vcf/'prefix'\", biome_id_column = \"sample_id\", file_type = \"vcf\")"},{"path":"/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Sol√®ne Pety. Author, maintainer, copyright holder. Ingrid David. Author, thesis advisor. Youna Mailli√©. Author. Andrea Rau. Author, thesis advisor. Mahendra Mariadassou. Author, thesis advisor.","code":""},{"path":"/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Pety S, David , Mailli√© Y, Rau , Mariadassou M (2025). RITHMS: Advanced Stochastic Framework Simulation Transgenerational Hologenomic Data. R package version 0.0.2, https://arxiv.org/abs/2502.07366.","code":"@Manual{,   title = {RITHMS: An Advanced Stochastic Framework for the Simulation of Transgenerational Hologenomic Data},   author = {Sol√®ne Pety and Ingrid David and Youna Mailli√© and Andrea Rau and Mahendra Mariadassou},   year = {2025},   note = {R package version 0.0.2},   url = {https://arxiv.org/abs/2502.07366}, }"},{"path":"/index.html","id":"rithms-","dir":"","previous_headings":"","what":"An Advanced Stochastic Framework for the Simulation of Transgenerational Hologenomic Data","title":"An Advanced Stochastic Framework for the Simulation of Transgenerational Hologenomic Data","text":"framework, R Implementation Transgenerational Hologenomic Model-based Simulator (RITHMS) open-source package, builds upon MoBPS package incorporates distinctive architecture microbiota, notably vertical horizontal transfer well modulation due environment host genetics. addition, RITHMS can account variety selection strategies, adaptable different genetic architectures. Full documentation website : https://SolenePety.github.io/RITHMS Last code version : https://github.com/SolenePety/RITHMS little summary RITHMS work, can read preprint details.","code":""},{"path":"/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"An Advanced Stochastic Framework for the Simulation of Transgenerational Hologenomic Data","text":"can install development version RITHMS GitHub using remotes shown .","code":"# install.packages(\"remotes\")  remotes::install_github(\"SolenePety/RITHMS\")"},{"path":"/index.html","id":"toy-dataset","dir":"","previous_headings":"","what":"Toy dataset","title":"An Advanced Stochastic Framework for the Simulation of Transgenerational Hologenomic Data","text":"already toy dataset, subset D√©ru et al.¬†2020, 1845 species 780 individuals, show expected structure input data : import dataset, can refer following vignette.","code":"library(RITHMS) data(\"Deru\") ToyData <- Deru"},{"path":"/index.html","id":"quick-start-from-the-toy-dataset","dir":"","previous_headings":"","what":"Quick Start from the toy dataset","title":"An Advanced Stochastic Framework for the Simulation of Transgenerational Hologenomic Data","text":"","code":"taxa_assign_g <- assign_taxa(ToyData) generations_simu <- holo_simu(h2 = 0.25,                               b2 = 0.25,                               founder_object = ToyData,                               n_clust = taxa_assign_g,                               n_ind = 500)"},{"path":"/index.html","id":"quick-start-from-your-own-dataset","dir":"","previous_headings":"","what":"Quick Start from your own dataset","title":"An Advanced Stochastic Framework for the Simulation of Transgenerational Hologenomic Data","text":"‚Äôre using dataset instead toy dataset, make sure calibrate simulation parameters accordingly. particular, n_ind (number individuals generation), genetic effect size effect.size multinomial sampling size parameter size_rmultinom used holo_simu() consistent characteristics dataset. help , please refer dedicated vignette.","code":"# from VCf format founder_object <- read_input_data(path_to_microbiome = \"/path/to/microbiome.txt\",                                   path_to_pedmap = \"/path/to/vcf/'prefix'\",                                   biome_id_column = \"ind_id\") # from Ped/Map format founder_object <- read_input_data(path_to_microbiome = \"/path/to/microbiome.txt\",                                   path_to_pedmap = \"/path/to/pedmap/'prefix'\",                                   biome_id_column = \"ind_id\")  taxa_assign_g <- assign_taxa(founder_object) generations_simu <- holo_simu(h2 = 0.25,                               b2 = 0.25,                                founder_object = founder_object,                               n_clust = taxa_assign_g,                               n_ind = 500,                               effect.size = 0.3,                               size_rmultinom = 10000) # Choose n_ind, effect.size and size_rmultinom such that it is consistent with the initial dimensions of your data set"},{"path":"/index.html","id":"to-go-further","dir":"","previous_headings":"","what":"To go further","title":"An Advanced Stochastic Framework for the Simulation of Transgenerational Hologenomic Data","text":"‚Äôre interested reproducing figures article can take look vignette generate figures coming article","code":""},{"path":"/reference/Deru.html","id":null,"dir":"Reference","previous_headings":"","what":"Deru Dataset ‚Äî Deru","title":"Deru Dataset ‚Äî Deru","text":"subset data D√©ru et al. 2020 containing hologenomic data 750 pigs fed conventional diet.","code":""},{"path":"/reference/Deru.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Deru Dataset ‚Äî Deru","text":"","code":"Deru"},{"path":"/reference/Deru.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Deru Dataset ‚Äî Deru","text":"list containing two different matrices, one microbiome genotypes. microbiome : matrix 780 rows (individuals) 1845 taxa, element represents abundance specific taxon specific individual. population : object MoBPS package provides genotypes individual, encoded 0, 1 ,2.","code":""},{"path":"/reference/Deru.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Deru Dataset ‚Äî Deru","text":"D√©ru et al. microbiota data D√©ru et al. 2020 genotypes data.","code":""},{"path":"/reference/Deru.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Deru Dataset ‚Äî Deru","text":"","code":"# Access the dataset data(\"Deru\")  # View the first few rows of the taxa matrix head(Deru$microbiome[1:5,1:5]) #>   OTU1 OTU2 OTU6793 OTU3 OTU4 #> 1   30  593       4  630  414 #> 2  254  275      62 1131  446 #> 3  181  487     164 1472  656 #> 4  469  665      45  640  328 #> 5  771  519      21  758  347  # Access the population object population <- Deru$population"},{"path":"/reference/calibrate_params_phenotypes.html","id":null,"dir":"Reference","previous_headings":"","what":"Calibration coefficients to compute phenotypes ‚Äî calibrate_params_phenotypes","title":"Calibration coefficients to compute phenotypes ‚Äî calibrate_params_phenotypes","text":"function part first step holo_simu(), focused calibrating phynotypes parameters looping generations. coefficents rescale process ensure standard deviation = 1 variance microbiote effect genetic effect satisfy target microbiability direct heritability.","code":""},{"path":"/reference/calibrate_params_phenotypes.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calibration coefficients to compute phenotypes ‚Äî calibrate_params_phenotypes","text":"","code":"calibrate_params_phenotypes(   X0,   B0,   h2,   b2,   otu_list,   Nqtl_y,   Notu_y = length(otu_list) )"},{"path":"/reference/calibrate_params_phenotypes.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calibration coefficients to compute phenotypes ‚Äî calibrate_params_phenotypes","text":"X0 Matrix primary generation genotypes, given get.geno() MoBPS function. SNPs rows individuals columns. B0 Matrix primary generation microbiomes, CLR abundances. OTUs rows individuals columns. h2 direct heritability value, 0 1. b2 microbiability value, 0 1. otu_list List causal OTUs phenotypes. Nqtl_y Integer; number causal SNPs phenotypes. Notu_y Integer; number causal OTUs phenotypes.","code":""},{"path":"/reference/calibrate_params_phenotypes.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calibration coefficients to compute phenotypes ‚Äî calibrate_params_phenotypes","text":"list phenotype parameters alpha, omega, list causal SNPs phenotypes, standard deviation (=1) phenotypes","code":""},{"path":[]},{"path":"/reference/calibrate_params_phenotypes.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calibration coefficients to compute phenotypes ‚Äî calibrate_params_phenotypes","text":"","code":"library(magrittr) n_ind <- 10 n_snp <- 50 n_otu <- 50  # Simulate a small genotype matrix  set.seed(123) X0 <- matrix(sample(0:2, n_snp * n_ind, replace = TRUE), nrow = n_snp, ncol = n_ind)  # Simulate a small microbiome counts matrix B0_counts_table <- matrix(abs(rnorm(n_snp * n_ind, mean = 10, sd = 3)), nrow = n_otu, ncol = n_ind)  # Transform to relative abundances per individuals and then apply CLR transformation B0_abund <- apply(B0_counts_table, 2, function(x) x/sum(x)) B0 <- compositions::clr(t(B0_abund)) %>% t()  # Randomly select causal OTUs rownames(B0) <- paste0(\"OTU\", 1:n_otu) otu_list <- c(y = sample(rownames(B0), 10))   params <- suppressWarnings(RITHMS:::calibrate_params_phenotypes(X0 = X0,                                       B0 = B0,                                       h2 = 0.25,                                       b2 = 0.25,                                       otu_list = otu_list,                                       Nqtl_y = 10,                                       Notu_y = length(otu_list))) str(params) #> List of 4 #>  $ alpha   : num [1:10] 0.000119 -0.139382 0.718991 -0.084337 -0.217468 ... #>  $ omega   : num [1:10] 1.147 1.564 1.253 -0.885 0.279 ... #>  $ qtl_list: int [1:10] 28 15 11 29 17 41 25 12 19 7 #>  $ se      : num [1, 1] 1"},{"path":"/reference/compute_beta_g.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute product of matrixes based on few parameters ‚Äî compute_beta_g","title":"Compute product of matrixes based on few parameters ‚Äî compute_beta_g","text":"function compute product matrix OTUs-specific genetic effects matrix genotypes. part gen_effect_calibration(), individual_level effects genotypes taxa computed.","code":""},{"path":"/reference/compute_beta_g.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute product of matrixes based on few parameters ‚Äî compute_beta_g","text":"","code":"compute_beta_g(beta, genotypes, noise, taxa_scale)"},{"path":"/reference/compute_beta_g.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute product of matrixes based on few parameters ‚Äî compute_beta_g","text":"beta matrix taxa (rows) across SNPs (columns) giving multiplicative effect genotype taxa abundances. Typically obtained compute_beta_matrix_cluster(). genotypes matrix genotypes SNPs rows individuals columns. noise numeric scalar indicating standard deviation Gaussian noise add. taxa_scale numeric scalar scale noise added OTUs abundance.","code":""},{"path":"/reference/compute_beta_g.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute product of matrixes based on few parameters ‚Äî compute_beta_g","text":"matrix taxa roxs individuals columns, element represents abundance given taxa individual, influenced genotype.","code":""},{"path":[]},{"path":"/reference/compute_beta_g.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compute product of matrixes based on few parameters ‚Äî compute_beta_g","text":"","code":"set.seed(123) n_taxa <- 5 n_snp <- 10 n_ind <- 50 # Simulate a small beta matrix beta <- matrix(sample(seq(0.1, 1, by = 0.05), size = n_taxa*n_snp, replace = TRUE), nrow = n_taxa, ncol = n_snp)  # Simulate a small genotype matrix genotypes <- matrix(sample(0:2, size = n_snp*n_ind, replace = TRUE), nrow = n_snp, ncol = n_ind)  # Compute beta_g matrix with noise beta_g <- RITHMS:::compute_beta_g(beta = beta,                                   genotypes = genotypes,                                   noise = 0.05,                                   taxa_scale = 1)"},{"path":"/reference/compute_beta_matrix_cluster.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate beta matrix giving genetic effect per SNP on taxa abundances. ‚Äî compute_beta_matrix_cluster","title":"Generate beta matrix giving genetic effect per SNP on taxa abundances. ‚Äî compute_beta_matrix_cluster","text":"Generate beta matrix giving genetic effect per SNP taxa abundances.","code":""},{"path":"/reference/compute_beta_matrix_cluster.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate beta matrix giving genetic effect per SNP on taxa abundances. ‚Äî compute_beta_matrix_cluster","text":"","code":"compute_beta_matrix_cluster(   n_b,   n_g,   n_clust,   n_qtl_o,   n_otus,   effect_size = 1,   correlation = 1,   beta_info = NULL )"},{"path":"/reference/compute_beta_matrix_cluster.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate beta matrix giving genetic effect per SNP on taxa abundances. ‚Äî compute_beta_matrix_cluster","text":"n_b Number taxa n_g Number SNPs n_clust vector length matching total number taxa values 0 number clusters. Typically assign_taxa() output. n_qtl_o Number causative QTL taxa abundances (per taxon) n_otus Number taxa genetic control. effect_size Vector giving size genetic effect try correlation numeric value 0 1 representing target correlation taxa within cluster. beta_info Informations Beta matrix genetic effects","code":""},{"path":"/reference/compute_beta_matrix_cluster.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate beta matrix giving genetic effect per SNP on taxa abundances. ‚Äî compute_beta_matrix_cluster","text":"list two objects linked beta matrix. beta matrix : matrix taxa (rows) across SNPs (columns) giving multiplicative effect genotype taxa abundances. small data.frame containing parameters used beta matrix simulation, including cluster, id_otu id_qtl_o.","code":""},{"path":[]},{"path":"/reference/compute_current_microbiome.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute microbiomes for all individuals of current generation gathering all relevant object already computed. ‚Äî compute_current_microbiome","title":"Compute microbiomes for all individuals of current generation gathering all relevant object already computed. ‚Äî compute_current_microbiome","text":"Compute microbiomes individuals current generation gathering relevant object already computed.","code":""},{"path":"/reference/compute_current_microbiome.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute microbiomes for all individuals of current generation gathering all relevant object already computed. ‚Äî compute_current_microbiome","text":"","code":"compute_current_microbiome(   beta,   current_genotypes,   mother_microbiomes,   mean_microbiome,   noise = 0.1,   taxa_scale,   lambda = 0.5,   dir = F,   thetaX )"},{"path":"/reference/compute_current_microbiome.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute microbiomes for all individuals of current generation gathering all relevant object already computed. ‚Äî compute_current_microbiome","text":"beta matrix taxa (rows) SNPs (columns) representing multiplicative effect SNPs taxa abundances. Typically output compute_beta_matrix_cluster() current_genotypes matrix genotypes individuals current generation. mother_microbiomes matrix containing CLR-transformed abundances microbiome current mothers. mean_microbiome numeric vector representing average abundances microbiome within population. noise numeric scalar indicating standard deviation Gaussian noise add beta g construction compute_beta_g()(multiplicative genetic effect taxa abundances). taxa_scale numeric scalar scale noise added OTUs abundance, see compute_beta_g(). lambda numeric 0 1 controlling relative contribution mother microbiome compared average microbiome. dir logical; thetaX matrix representing environmental effect (optional).","code":""},{"path":"/reference/compute_current_microbiome.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute microbiomes for all individuals of current generation gathering all relevant object already computed. ‚Äî compute_current_microbiome","text":"matrix CLR-transformed abundances microbiome individual current generation.","code":""},{"path":[]},{"path":"/reference/compute_mean_microbiome.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute the mean for each taxa across population ‚Äî compute_mean_microbiome","title":"Compute the mean for each taxa across population ‚Äî compute_mean_microbiome","text":"function estimate mean microbiome averaging abundances across individuals taxa. Optionally, use Dirichlet distribution simulate inter-individual variability centered arround mean.","code":""},{"path":"/reference/compute_mean_microbiome.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute the mean for each taxa across population ‚Äî compute_mean_microbiome","text":"","code":"compute_mean_microbiome(microbiome, dir = F, n_ind = NULL, ao, mix.params)"},{"path":"/reference/compute_mean_microbiome.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute the mean for each taxa across population ‚Äî compute_mean_microbiome","text":"microbiome matrix microbiome abundances (taxa rows, individuals columns). dir logical; TRUE, use Dirichlet distribution simulate inter-individual variability. Default FALSE. n_ind number individuals simulate Dirichlet distribution (required dir = TRUE). ao numeric scalar used concentration parameter Dirichlet distribution. mix.params numeric vector (length = 2) specifying weights Dirichlet samples original mean. weigths sum 1.","code":""},{"path":"/reference/compute_mean_microbiome.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute the mean for each taxa across population ‚Äî compute_mean_microbiome","text":"numericvector mean microbiome values dir = FALSE. matrix simulated microbiomes dir = TRUE","code":""},{"path":[]},{"path":"/reference/compute_phenotypes.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute phenotype values based on generated objects of the current generation ‚Äî compute_phenotypes","title":"Compute phenotype values based on generated objects of the current generation ‚Äî compute_phenotypes","text":"Compute phenotype values based generated objects current generation","code":""},{"path":"/reference/compute_phenotypes.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute phenotype values based on generated objects of the current generation ‚Äî compute_phenotypes","text":"","code":"compute_phenotypes(   X,   B,   otu_list,   qtl_list,   beta_qtl,   beta_otu,   Nqtl_y,   Notu_y,   se )"},{"path":"/reference/compute_phenotypes.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute phenotype values based on generated objects of the current generation ‚Äî compute_phenotypes","text":"X matrix current generation genotypes, encoding 0, 1 2. B matrix CLR-transformed abundances current generation microbiome. otu_list List causal OTUs phenotypes. qtl_list List causal SNPs phenotypes. beta_qtl Alpha, regression coefficients corresponding QTL effects phenotype. See calibrate_params_phenotypes(). beta_otu Omega, regression coefficients corresponding taxa effects phenotype. See calibrate_params_phenotypes(). Nqtl_y Integer, number causal SNPs phenotypes. Notu_y Integer, number causal OTUs phenotypes. se Phenotypes Standard deviation, see calibrate_params_phenotypes().","code":""},{"path":[]},{"path":"/reference/formatting_data.html","id":null,"dir":"Reference","previous_headings":"","what":"Assign all taxa to a cluster, eventually under genetic control using hclust ‚Äî assign_taxa","title":"Assign all taxa to a cluster, eventually under genetic control using hclust ‚Äî assign_taxa","text":"Assign taxa cluster, eventually genetic control using hclust","code":""},{"path":"/reference/formatting_data.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Assign all taxa to a cluster, eventually under genetic control using hclust ‚Äî assign_taxa","text":"","code":"assign_taxa(founder_object, taxa_g = 0.05)"},{"path":"/reference/formatting_data.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Assign all taxa to a cluster, eventually under genetic control using hclust ‚Äî assign_taxa","text":"founder_object Output read_input_data function taxa_g Percentage taxa genetic control, DEFAULT = 0.1","code":""},{"path":"/reference/formatting_data.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Assign all taxa to a cluster, eventually under genetic control using hclust ‚Äî assign_taxa","text":"vector length matching total number taxa values 0 number clusters, 0 corresponding non genetic control cluster","code":""},{"path":"/reference/formatting_data.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Assign all taxa to a cluster, eventually under genetic control using hclust ‚Äî assign_taxa","text":"","code":"data(\"Deru\") ToyData <- Deru taxa_assign_g <- assign_taxa(founder_object = ToyData,             taxa_g = 0.2)"},{"path":"/reference/gen_effect_calibration.html","id":null,"dir":"Reference","previous_headings":"","what":"Calibration of genetic effect from founder population data ‚Äî gen_effect_calibration","title":"Calibration of genetic effect from founder population data ‚Äî gen_effect_calibration","text":"Calibration genetic effect founder population data","code":""},{"path":"/reference/gen_effect_calibration.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calibration of genetic effect from founder population data ‚Äî gen_effect_calibration","text":"","code":"gen_effect_calibration(   founder_object,   taxa_assign_g,   correlation = 0.5,   effect.size = c(seq(0.1, 1, 0.1)),   plot = T )"},{"path":"/reference/gen_effect_calibration.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calibration of genetic effect from founder population data ‚Äî gen_effect_calibration","text":"founder_object Output generate_founder() read_input_data() function taxa_assign_g Factor vector giving cluster assignment taxa, typical output assign_taxa() correlation Correlation taxa within cluster, value 0 1, DEFAULT = 0.5 effect.size Vector giving size genetic effect try plot boolean, plot generation required, DEFAULT = TRUE","code":""},{"path":"/reference/gen_effect_calibration.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calibration of genetic effect from founder population data ‚Äî gen_effect_calibration","text":"data.frame three columns, giving Taxa ID, effect.size corresponding heritability","code":""},{"path":"/reference/gen_effect_calibration.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calibration of genetic effect from founder population data ‚Äî gen_effect_calibration","text":"","code":"data(\"Deru\") ToyData <- Deru taxa_assign_g <- assign_taxa(founder_object = ToyData) effect_size_vector <- c(seq(0.1,1, by = 0.2)) out_data <- gen_effect_calibration(founder_object = ToyData,                                    taxa_assign_g = taxa_assign_g,                                    correlation = 0.5,                                    effect.size = effect_size_vector,                                    plot = TRUE)  #> Picking joint bandwidth of 0.0299"},{"path":"/reference/generate_founder.html","id":null,"dir":"Reference","previous_headings":"","what":"Formatting of ped/map files or vcf into haplotypes table and add it inside the founder_object list. ‚Äî generate_founder","title":"Formatting of ped/map files or vcf into haplotypes table and add it inside the founder_object list. ‚Äî generate_founder","text":"Formatting ped/map files vcf haplotypes table add inside founder_object list.","code":""},{"path":"/reference/generate_founder.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Formatting of ped/map files or vcf into haplotypes table and add it inside the founder_object list. ‚Äî generate_founder","text":"","code":"generate_founder(path = NULL, microbiome_matrix, file_type = \"pedmap\")"},{"path":"/reference/generate_founder.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Formatting of ped/map files or vcf into haplotypes table and add it inside the founder_object list. ‚Äî generate_founder","text":"path String giving path prefix ped map file microbiome_matrix Filtered microbiome matrix, OTUs columns individuals rows file_type String specifying file type used load genotype data. one \"pedmap\" \"vcf\". (default: \"pedmap\").","code":""},{"path":"/reference/generate_founder.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Formatting of ped/map files or vcf into haplotypes table and add it inside the founder_object list. ‚Äî generate_founder","text":"list two matrix. microbiome matrix contains taxa (columns) accross individuals (rows). population object contains genotypes, encoded 0,1,2 generated using MoBPS package.","code":""},{"path":[]},{"path":"/reference/generate_founder.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Formatting of ped/map files or vcf into haplotypes table and add it inside the founder_object list. ‚Äî generate_founder","text":"","code":"if (FALSE) { # \\dontrun{   # Generate founder object from PED/MAP set   microbiome <- data.table::fread(\"/path/to/microbiome.txt\")   founder_object <- generate_founder(path = \"/path/to/pedmap\", microbiome, file_type = \"pedmap\")      # Generate founder object from VCF set   microbiome <- data.table::fread(\"/path/to/microbiome.txt\")   founder_object <- generate_founder(path = \"/path/to/vcf\", microbiome, file_type = \"vcf\")  } # }"},{"path":"/reference/get_mean_diversity.html","id":null,"dir":"Reference","previous_headings":"","what":"Useful function to extract Shannon diversity from RITHMS output ‚Äî get_mean_diversity","title":"Useful function to extract Shannon diversity from RITHMS output ‚Äî get_mean_diversity","text":"gets functions use output holo_simu() extract information interest given generation. get_mean_diversityextract average Shannon diversity generation object.","code":""},{"path":"/reference/get_mean_diversity.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Useful function to extract Shannon diversity from RITHMS output ‚Äî get_mean_diversity","text":"","code":"get_mean_diversity(data)"},{"path":"/reference/get_mean_diversity.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Useful function to extract Shannon diversity from RITHMS output ‚Äî get_mean_diversity","text":"data List corresponding one generation, returned holo_simu(). Containing simulation output.","code":""},{"path":"/reference/get_mean_diversity.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Useful function to extract Shannon diversity from RITHMS output ‚Äî get_mean_diversity","text":"average Shannon diversity within given generation.","code":""},{"path":"/reference/get_mean_diversity.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Useful function to extract Shannon diversity from RITHMS output ‚Äî get_mean_diversity","text":"function requires previous call richness_from_abundances_gen() compute different types diversity within generation.","code":""},{"path":[]},{"path":"/reference/get_mean_diversity.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Useful function to extract Shannon diversity from RITHMS output ‚Äî get_mean_diversity","text":"","code":"if (FALSE) { # \\dontrun{ library(magrittr) library(purrr) data(\"Deru\") ToyData <- Deru taxa_assign_g <- assign_taxa(founder_object = ToyData) generations_simu <- holo_simu(h2 = 0.25, b2 = 0.25, founder_object = ToyData,                               n_clust = taxa_assign_g, n_ind = 500,                               verbose = FALSE, seed = 1234)                                # Extract Shannon diversity for each generations ## First step, compute richness from abundances richness_from_abundances <- generations_simu[-1] %>% map(get_microbiomes) %>% map(richness_from_abundances_gen, size_rmultinom = 10000) ## size_rmultinom = 10000 according to DeruPops dataset  mean_shannon_diversity <- richness_from_abundances %>% map(get_mean_diversity) } # } if (FALSE) { # \\dontrun{ library(magrittr) library(purrr)  data(\"Deru\") ToyData <- Deru taxa_assign_g <- assign_taxa(founder_object = ToyData) generations_simu <- holo_simu(h2 = 0.25,                               b2 = 0.25,                               founder_object = ToyData,                               n_clust = taxa_assign_g,                               n_ind = 500,                               verbose = FALSE,                               noise.microbiome = 0.5,                               effect.size = 0.3,                               lambda = 0.5,                               dir = TRUE,                               selection = FALSE,                               seed = 1234)  # To extract CLR abundances of the G1 generation microbiome G1_microbiome <- get_microbiomes(generations_simu$G1, CLR = TRUE)  # To extract all the relative abundances of microbiomes from all generations # substract metadata microbiomes <- generations_simu[-1] %>% map(get_microbiomes)  # To extract mean phenotypes of all generations mean_phenotypes <- generations_simu[-1] %>% map(get_mean_phenotypes)  # To extract phenotypic values for each individual of generation G1 G1_phenotypes_values <- get_phenotypes_value(generations_simu$G1)  # To extract the phenotype of each generation as the combined effects of microbiota and direct genetic effects phenotypes <- generations_simu[-1] %>% map(get_phenotypes)  # To extract omega beta G values for each individual of generation G1 G1_om_beta_g <- get_om_beta_g(generations_simu$G1)  # To extract ID of selected individuals to each generation selected_inds <- generations_simu[-1] %>% map(get_selected_ind)   # To extract Shannon diversity # First step, compute richness from abundances richness_from_abundances <- generations_simu[-1] %>% map(get_microbiomes) %>% map(richness_from_abundances_gen) shannon_diversity <- richness_from_abundances %>% map(get_mean_diversity) } # }"},{"path":"/reference/get_mean_phenotypes.html","id":null,"dir":"Reference","previous_headings":"","what":"Useful function to extract mean phenotype values from RITHMS output ‚Äî get_mean_phenotypes","title":"Useful function to extract mean phenotype values from RITHMS output ‚Äî get_mean_phenotypes","text":"gets functions use output holo_simu() extract information interest given generation. get_mean_phenotypesextract average phenotype generation object.","code":""},{"path":"/reference/get_mean_phenotypes.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Useful function to extract mean phenotype values from RITHMS output ‚Äî get_mean_phenotypes","text":"","code":"get_mean_phenotypes(data)"},{"path":"/reference/get_mean_phenotypes.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Useful function to extract mean phenotype values from RITHMS output ‚Äî get_mean_phenotypes","text":"data List corresponding one generation, returned holo_simu(). Containing simulation output.","code":""},{"path":"/reference/get_mean_phenotypes.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Useful function to extract mean phenotype values from RITHMS output ‚Äî get_mean_phenotypes","text":"mean phenotype value given generation.","code":""},{"path":[]},{"path":"/reference/get_mean_phenotypes.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Useful function to extract mean phenotype values from RITHMS output ‚Äî get_mean_phenotypes","text":"","code":"if (FALSE) { # \\dontrun{ library(purrr) library(magrittr) data(\"Deru\") ToyData <- Deru taxa_assign_g <- assign_taxa(founder_object = ToyData) generations_simu <- holo_simu(h2 = 0.25, b2 = 0.25, founder_object = ToyData,                               n_clust = taxa_assign_g, n_ind = 500,                               verbose = FALSE, seed = 1234)                                # Extract mean phenotype value for G1 generation G1_mean_phenotype <- get_mean_phenotypes(generations_simu$G1)  # Extract mean phenotype values of all generations ## Don't forget to substract the metadata mean_phenotypes <- generations_simu[-1] %>% map(get_mean_phenotypes) } # }"},{"path":"/reference/get_microbiomes.html","id":null,"dir":"Reference","previous_headings":"","what":"Useful function to extract microbiomes from RITHMS output ‚Äî get_microbiomes","title":"Useful function to extract microbiomes from RITHMS output ‚Äî get_microbiomes","text":"gets functions use output holo_simu() extract information interest given generation. get_microbiomes extract microbiome abundance matrix generation object, without CLR transformation transposition.","code":""},{"path":"/reference/get_microbiomes.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Useful function to extract microbiomes from RITHMS output ‚Äî get_microbiomes","text":"","code":"get_microbiomes(data, transpose = F, CLR = F)"},{"path":"/reference/get_microbiomes.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Useful function to extract microbiomes from RITHMS output ‚Äî get_microbiomes","text":"data List corresponding one generation, returned holo_simu(). Containing simulation output. transpose Logical; TRUE, transpose microbiome matrix (OTUs rows, individuals columns). CLR Logical; TRUE, applies CLR transformation abundance data. transformation requires transpose = TRUE.","code":""},{"path":"/reference/get_microbiomes.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Useful function to extract microbiomes from RITHMS output ‚Äî get_microbiomes","text":"data.framecontaining microbiome abundances individuals. Default, individuals rows OTUs columns. Change transposeparameter needed.","code":""},{"path":[]},{"path":"/reference/get_microbiomes.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Useful function to extract microbiomes from RITHMS output ‚Äî get_microbiomes","text":"","code":"if (FALSE) { # \\dontrun{ library(magrittr) library(purrr) data(\"Deru\") ToyData <- Deru taxa_assign_g <- assign_taxa(founder_object = ToyData) generations_simu <- holo_simu(h2 = 0.25, b2 = 0.25, founder_object = ToyData,                               n_clust = taxa_assign_g, n_ind = 500,                               verbose = FALSE, seed = 1234)  # Extract microbiome matrix for G1 generation G1_microbiome <- get_microbiomes(generations_simu$G1)  # Extract with transposition G1_t_microbiome <- get_microbiomes(generations_simu$G1, transpose = TRUE)  # Extract with CLR transformation G1_CLR_microbiome <- get_microbiomes(generations_simu$G1, transpose = TRUE, CLR = TRUE)  # Extract all microbiome matrices of all generations # substract metadata microbiomes <- generations_simu[-1] %>% map(get_microbiomes) } # }"},{"path":"/reference/get_om_beta_g.html","id":null,"dir":"Reference","previous_headings":"","what":"Useful function to extract omega beta G values from RITHMS output ‚Äî get_om_beta_g","title":"Useful function to extract omega beta G values from RITHMS output ‚Äî get_om_beta_g","text":"gets functions use output holo_simu() extract information interest given generation. get_om_beta_gextract omega beta G values generation object.","code":""},{"path":"/reference/get_om_beta_g.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Useful function to extract omega beta G values from RITHMS output ‚Äî get_om_beta_g","text":"","code":"get_om_beta_g(data)"},{"path":"/reference/get_om_beta_g.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Useful function to extract omega beta G values from RITHMS output ‚Äî get_om_beta_g","text":"data List corresponding one generation, returned holo_simu(). Containing simulation output.","code":""},{"path":"/reference/get_om_beta_g.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Useful function to extract omega beta G values from RITHMS output ‚Äî get_om_beta_g","text":"data.frame omega beta G values individuals given generation.","code":""},{"path":[]},{"path":"/reference/get_om_beta_g.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Useful function to extract omega beta G values from RITHMS output ‚Äî get_om_beta_g","text":"","code":"if (FALSE) { # \\dontrun{ library(magrittr) library(purrr) data(\"Deru\") ToyData <- Deru taxa_assign_g <- assign_taxa(founder_object = ToyData) generations_simu <- holo_simu(h2 = 0.25, b2 = 0.25, founder_object = ToyData,                               n_clust = taxa_assign_g, n_ind = 500,                               verbose = FALSE, seed = 1234)                                #Extract omega beta G values for each individuals of G1 generation G1_om_beta_g <- get_om_beta_g(generations_simu$G1)   #Extract omega beta G values for each individuals of all generations ## Don't forget to substract the metadata om_beta_g <- generations_simu[-1] %>% map(get_om_beta_g) } # }"},{"path":"/reference/get_phenotypes.html","id":null,"dir":"Reference","previous_headings":"","what":"Useful function to extract all phenotype values as data frame from RITHMS output ‚Äî get_phenotypes","title":"Useful function to extract all phenotype values as data frame from RITHMS output ‚Äî get_phenotypes","text":"gets functions use output holo_simu() extract information interest given generation. get_phenotypesextract phenotype individuals combined effects microbiota direct genetic effects, generation object.","code":""},{"path":"/reference/get_phenotypes.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Useful function to extract all phenotype values as data frame from RITHMS output ‚Äî get_phenotypes","text":"","code":"get_phenotypes(data)"},{"path":"/reference/get_phenotypes.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Useful function to extract all phenotype values as data frame from RITHMS output ‚Äî get_phenotypes","text":"data List corresponding one generation, returned holo_simu(). Containing simulation output.","code":""},{"path":"/reference/get_phenotypes.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Useful function to extract all phenotype values as data frame from RITHMS output ‚Äî get_phenotypes","text":"data.frame phenotype individuals given generation. Phenotype values given result combined effects microbiota direct genetic effects.","code":""},{"path":[]},{"path":"/reference/get_phenotypes.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Useful function to extract all phenotype values as data frame from RITHMS output ‚Äî get_phenotypes","text":"","code":"if (FALSE) { # \\dontrun{ library(magrittr) library(purrr) data(\"Deru\") ToyData <- Deru taxa_assign_g <- assign_taxa(founder_object = ToyData) generations_simu <- holo_simu(h2 = 0.25, b2 = 0.25, founder_object = ToyData,                               n_clust = taxa_assign_g, n_ind = 500,                               verbose = FALSE, seed = 1234)                                #Extract phenotypes of the G1 generation G1_phenotypes <- get_phenotypes(generations_simu$G1)   #Extract phenotypes for all generations ## Don't forget to substract the metadata phenotypes <- generations_simu[-1] %>% map(get_phenotypes) } # }"},{"path":"/reference/get_phenotypes_value.html","id":null,"dir":"Reference","previous_headings":"","what":"Useful function to extract phenotype values from RITHMS output (","title":"Useful function to extract phenotype values from RITHMS output (","text":"gets functions use output holo_simu() extract information interest given generation. get_phenotypes_values extract set phenotype values generation object.","code":""},{"path":"/reference/get_phenotypes_value.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Useful function to extract phenotype values from RITHMS output (","text":"","code":"get_phenotypes_value(data, value = \"gq\")"},{"path":"/reference/get_phenotypes_value.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Useful function to extract phenotype values from RITHMS output (","text":"data List corresponding one generation, returned holo_simu(). Containing simulation output. value String caracter precise object extract generation object. Must \"gq\" extract phenotype values.","code":""},{"path":"/reference/get_phenotypes_value.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Useful function to extract phenotype values from RITHMS output (","text":"data.frame phenotype values individuals given generation.","code":""},{"path":[]},{"path":"/reference/get_phenotypes_value.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Useful function to extract phenotype values from RITHMS output (","text":"","code":"if (FALSE) { # \\dontrun{ library(magrittr) library(purrr) data(\"Deru\") ToyData <- Deru taxa_assign_g <- assign_taxa(founder_object = ToyData) generations_simu <- holo_simu(h2 = 0.25, b2 = 0.25, founder_object = ToyData,                               n_clust = taxa_assign_g, n_ind = 500,                               verbose = FALSE, seed = 1234)                                 #Extract phenotype values for each individuals of G1 generation  G1_phenotypes_values <- get_phenotypes_value(generations_simu$G1)    #Extract phenotype values for each individuals of all generations  ## Don't forget to substract the metadata  phenotypes_values <- generations_simu[-1] %>% map(get_phenotypes_value)  } # }"},{"path":"/reference/get_selected_ind.html","id":null,"dir":"Reference","previous_headings":"","what":"Useful function to extract ID of selected individuals from RITHMS output ‚Äî get_selected_ind","title":"Useful function to extract ID of selected individuals from RITHMS output ‚Äî get_selected_ind","text":"gets functions use output holo_simu() extract information interest given generation. get_selected_indextract selectd individuals IDs generation object.","code":""},{"path":"/reference/get_selected_ind.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Useful function to extract ID of selected individuals from RITHMS output ‚Äî get_selected_ind","text":"","code":"get_selected_ind(data)"},{"path":"/reference/get_selected_ind.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Useful function to extract ID of selected individuals from RITHMS output ‚Äî get_selected_ind","text":"data List corresponding one generation, returned holo_simu(). Containing simulation output.","code":""},{"path":"/reference/get_selected_ind.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Useful function to extract ID of selected individuals from RITHMS output ‚Äî get_selected_ind","text":"Alist selected individuals given generation.","code":""},{"path":[]},{"path":"/reference/get_selected_ind.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Useful function to extract ID of selected individuals from RITHMS output ‚Äî get_selected_ind","text":"","code":"if (FALSE) { # \\dontrun{ library(magrittr) library(purrr) data(\"Deru\") ToyData <- Deru taxa_assign_g <- assign_taxa(founder_object = ToyData) generations_simu <- holo_simu(h2 = 0.25, b2 = 0.25, founder_object = ToyData,                               n_clust = taxa_assign_g, n_ind = 500,                               verbose = FALSE, seed = 1234)                                #Extract selected individuals IDs for the G1 generation G1_selected_ind <- get_selected_ind(generations_simu$G1)   #Extract selected individuals IDs for all generations ## Don't forget to substract the metadata selected_ind <- generations_simu[-1] %>% map(get_selected_ind) } # }"},{"path":"/reference/holo_simu.html","id":null,"dir":"Reference","previous_headings":"","what":"Main function to generate transgenerational hologenomic data ‚Äî holo_simu","title":"Main function to generate transgenerational hologenomic data ‚Äî holo_simu","text":"Simulates hologenomic data multiple generations genetic, microbial, environmental effects.","code":""},{"path":"/reference/holo_simu.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Main function to generate transgenerational hologenomic data ‚Äî holo_simu","text":"","code":"holo_simu(   h2,   b2,   founder_object,   n_ind = NULL,   n_clust = NULL,   n_gen = 5,   qtn_y = NULL,   correlation = 0.5,   otu_g = 0.05,   lambda = 0.5,   effect.size = 0.1,   mix.params = c(0.75, 0.25),   mix.params.M = c(0.75, 0.25),   noise.microbiome = 0.1,   dir = T,   ao = 25,   size_rmultinom = 10000,   selection = F,   size_selection_F = NULL,   size_selection_M = NULL,   selection_type = \"GB\",   w.param = c(0.5, 0.5),   thetaX = NULL,   env_gen = NULL,   seed = 1234,   verbose = T )"},{"path":"/reference/holo_simu.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Main function to generate transgenerational hologenomic data ‚Äî holo_simu","text":"h2 direct heritability value, 0 1. b2 microbiability value, 0 1. founder_object output generate_founder() function. n_ind number individual per generation. n_clust vector taxa assignment, typical output assign_taxa() n_gen number generation, DEFAULT = 5 qtn_y number causal SNPs phenotypes. correlation Correlation taxa within cluster, value 0 1, DEFAULT = 0.5 otu_g percentage taxa genetic control, 0 1, DEFAULT = 0.05 lambda proportion microbiome offspring coming vertical transmission, DEFAULT = 0.5 effect.size Vector giving size genetic effect try. mix.params Vector two numeric values giving weights regularisation base population microbiome. mix.params[1] = weight raw microbiome mix.params[2] = weight mean microbiome. DEFAULT = c(0.75,0.25). mix.params.M vector two numeric values specifying weights Dirichlet samples original mean. DEFAULT = c(0.75,0.25). mix.params.M[1] dirichlet microbiome coefficient mix.params.M[2] mean microbiome coefficient. noise.microbiome sd microbiome noise, DEFAULT = 0.1 dir Logical; Mentions ambient microbiome generated via Dirichlet law mean_microbiome. DEFAULT = T ao numeric scalar used concentration parameter Dirichlet distribution. size_rmultinom Integer; specifying total number object multinomial sampling(default: 10000, according DeruPop.rds dataset). selection bool, selection process needed, DEFAULT = FALSE size_selection_F percentage female select. size_selection_M percentage male select. selection_type mode selection used, value (\"GB\", \"B\", \"G\", \"diversity\", \"div.GB\"), DEFAULT = \"GB\" w.param case div.GB selection mode chosen. thetaX Optionnal matrix specifying environmental effects applied microbiome, antibiotic treatment. matrix dimension n_taxa x n_individuals, typically constructed product : vector taxa-specific effects theta (negative positive values taxa). binary vector X encoding individual exposure (1 treated, 0 ofr untreated). NULL (default value), environmental effect applied. Example use case: refer vignette Generate figures env_gen vector booleans. seed seed value samplings function. verbose bool, DEFAULT = T","code":""},{"path":"/reference/holo_simu.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Main function to generate transgenerational hologenomic data ‚Äî holo_simu","text":"important list several different objects : parameters: set parameters used simulation calling holo_simu() metadata: metadata info beta matrix details G0 G5 (5 generations default): computational characteristics generations. generation, genotypes, microbiomes, phenotypes, pedigree individuals selected can reachable.","code":""},{"path":"/reference/holo_simu.html","id":"required-parameters","dir":"Reference","previous_headings":"","what":"Required parameters","title":"Main function to generate transgenerational hologenomic data ‚Äî holo_simu","text":"h2 b2 founder_object n_ind n_clust","code":""},{"path":"/reference/holo_simu.html","id":"generation-parameters","dir":"Reference","previous_headings":"","what":"Generation parameters","title":"Main function to generate transgenerational hologenomic data ‚Äî holo_simu","text":"n_gen","code":""},{"path":"/reference/holo_simu.html","id":"genotype-related-parameters","dir":"Reference","previous_headings":"","what":"Genotype-related parameters","title":"Main function to generate transgenerational hologenomic data ‚Äî holo_simu","text":"qtn_y","code":""},{"path":"/reference/holo_simu.html","id":"microbiome-related-parameters","dir":"Reference","previous_headings":"","what":"Microbiome-related parameters","title":"Main function to generate transgenerational hologenomic data ‚Äî holo_simu","text":"correlation otu_g lambda effect.size mix.params mix.params.M noise.microbiome dir ao","code":""},{"path":"/reference/holo_simu.html","id":"selection-related-parameters","dir":"Reference","previous_headings":"","what":"Selection-related parameters","title":"Main function to generate transgenerational hologenomic data ‚Äî holo_simu","text":"selection size_selection_F, size_selection_M selection_type","code":""},{"path":"/reference/holo_simu.html","id":"environmental-effects","dir":"Reference","previous_headings":"","what":"Environmental effects","title":"Main function to generate transgenerational hologenomic data ‚Äî holo_simu","text":"thetaX env_gen","code":""},{"path":"/reference/holo_simu.html","id":"misc","dir":"Reference","previous_headings":"","what":"Misc","title":"Main function to generate transgenerational hologenomic data ‚Äî holo_simu","text":"seed verbose","code":""},{"path":[]},{"path":"/reference/holo_simu.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Main function to generate transgenerational hologenomic data ‚Äî holo_simu","text":"","code":"if (FALSE) { # \\dontrun{   data(\"Deru\")   ToyData <- Deru   taxa_assign_g <- assign_taxa(founder_object = ToyData)   generations_simu <- holo_simu(h2 = 0.25,                                  b2 = 0.25,                                  founder_object = ToyData,                                  n_clust = taxa_assign_g,                                  n_ind = 500,                                  verbose = FALSE,                                  noise.microbiome = 0.5,                                  effect.size = 0.3,                                  lambda = 0.5,                                  dir = TRUE,                                  selection = FALSE,                                  seed = 1234) } # }"},{"path":"/reference/rarefied_microbiome.html","id":null,"dir":"Reference","previous_headings":"","what":"Rarefaction step within read_input_data ‚Äî rarefied_microbiome","title":"Rarefaction step within read_input_data ‚Äî rarefied_microbiome","text":"Rarefaction step within read_input_data","code":""},{"path":"/reference/rarefied_microbiome.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Rarefaction step within read_input_data ‚Äî rarefied_microbiome","text":"","code":"rarefied_microbiome(microbiome_matrix, id_column = \"ind_id\", threshold = 0.05)"},{"path":"/reference/rarefied_microbiome.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Rarefaction step within read_input_data ‚Äî rarefied_microbiome","text":"microbiome_matrix Microbiome counting table, OTUs columns column specifying IDs id_column String specifying name column containing individual IDs. Default \"ind_id\" threshold Minimum prevalence threshold","code":""},{"path":"/reference/rarefied_microbiome.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Rarefaction step within read_input_data ‚Äî rarefied_microbiome","text":"filtered microbiome matrix, without OTUs whose prevalence lower set threshold","code":""},{"path":[]},{"path":"/reference/rarefied_microbiome.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Rarefaction step within read_input_data ‚Äî rarefied_microbiome","text":"","code":"if (FALSE) { # \\dontrun{   microbiome <- data.table::fread(\"/path/to/microbiome.txt\")   microbiome_filtered <- rarefied_microbiome(microbiome, id_columns = \"sample_id\", threshold = 0.05) } # }"},{"path":"/reference/read_input_data.html","id":null,"dir":"Reference","previous_headings":"","what":"Formatting data from file paths to base population object ‚Äî read_input_data","title":"Formatting data from file paths to base population object ‚Äî read_input_data","text":"Formatting data file paths base population object","code":""},{"path":"/reference/read_input_data.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Formatting data from file paths to base population object ‚Äî read_input_data","text":"","code":"read_input_data(   path_to_microbiome,   path_to_genotype,   file_type = \"pedmap\",   biome_id_column = \"ind_id\",   threshold = 0.05,   ind_selected = NULL )"},{"path":"/reference/read_input_data.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Formatting data from file paths to base population object ‚Äî read_input_data","text":"path_to_microbiome String giving path count table file. \"path//microbiome.{extension}\" path_to_genotype String giving path prefix genotype file. one \"pedmap\" \"vcf\". (default: \"pedmap\"), see file_type param. \"example_pedmap.ped\" file enter \"path//example_pedmap\". file_type String specifying file type used load genotype data. one \"pedmap\" \"vcf\". (default: \"pedmap\"). biome_id_column String specifying name column containing individual IDs microbiome matrix. Default \"ind_id\". threshold Threshold rarefaction, DEFAULT = 0.05 ind_selected Vector string values individuals keep, match rownames count table file, DEFAULT = NULL","code":""},{"path":"/reference/read_input_data.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Formatting data from file paths to base population object ‚Äî read_input_data","text":"list containing two object. matrix containing microbiome(microbiome). list MoBPS package, containing genotypes (population). Individuals columns taxa SNPs rows.","code":""},{"path":"/reference/read_input_data.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Formatting data from file paths to base population object ‚Äî read_input_data","text":"number individuals microbiome genotype data must equivalent.","code":""},{"path":[]},{"path":"/reference/read_input_data.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Formatting data from file paths to base population object ‚Äî read_input_data","text":"","code":"if (FALSE) { # \\dontrun{ # Create founder object from PED/MAP set founder_object <- read_input_data(path_to_microbiome = \"/path/to/microbiome.txt\",                                   path_to_pedmap = \"/path/to/pedmap/'prefix'\",                                   biome_id_column = \"ind_id\",                                   threshold = 0.05,                                   ind_selected = NULL,                                   file_type = \"pedmap\")  # Create founder object from VCF founder_object <- read_input_data(path_to_microbiome = \"/path/to/microbiome.txt\",                                   path_to_pedmap = \"/path/to/vcf/'prefix'\",                                   biome_id_column = \"ind_id\",                                   threshold = 0.05,                                   ind_selected = NULL,                                   file_type = \"vcf\") } # }"},{"path":"/reference/replace_zero.html","id":null,"dir":"Reference","previous_headings":"","what":"Replace zero in the matrix by 1e-15 to avoid infinite values when CLR transformation is computed ‚Äî replace_zero","title":"Replace zero in the matrix by 1e-15 to avoid infinite values when CLR transformation is computed ‚Äî replace_zero","text":"Replace zero matrix 1e-15 avoid infinite values CLR transformation computed","code":""},{"path":"/reference/replace_zero.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Replace zero in the matrix by 1e-15 to avoid infinite values when CLR transformation is computed ‚Äî replace_zero","text":"","code":"replace_zero(x)"},{"path":"/reference/replace_zero.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Replace zero in the matrix by 1e-15 to avoid infinite values when CLR transformation is computed ‚Äî replace_zero","text":"x matrix","code":""},{"path":"/reference/richness_from_abundances_gen.html","id":null,"dir":"Reference","previous_headings":"","what":"Estimate diversity metrics from relative abundances ‚Äî richness_from_abundances_gen","title":"Estimate diversity metrics from relative abundances ‚Äî richness_from_abundances_gen","text":"function estimate diversity metrics (Observed, Shannon, Inverse Simpson) matrix relative abundances (see get_microbiomes()). uses multinomial sampling simulate read counts abundances, computes diversity metrics across n_loop order obtain robust estimation. function particularly useful selection based diversity.","code":""},{"path":"/reference/richness_from_abundances_gen.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Estimate diversity metrics from relative abundances ‚Äî richness_from_abundances_gen","text":"","code":"richness_from_abundances_gen(   microbiome_matrix,   size_rmultinom = 10000,   n_loop = 10,   plot = T )"},{"path":"/reference/richness_from_abundances_gen.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Estimate diversity metrics from relative abundances ‚Äî richness_from_abundances_gen","text":"microbiome_matrix matrix relative abundances (individuals rows OTUs columns, see get_microbiomes() output). size_rmultinom Integer; specifying total number object multinomial sampling(default: 10000, according DeruPop.rds dataset). n_loop Integer; number multinomial resampling iterations perform (default: 10). plot Logical; currently implemented","code":""},{"path":"/reference/richness_from_abundances_gen.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Estimate diversity metrics from relative abundances ‚Äî richness_from_abundances_gen","text":"data.frameof average diversity metrics (Observed, Shannon, Inverse Simpson) sample.","code":""},{"path":[]},{"path":"/reference/richness_from_abundances_gen.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Estimate diversity metrics from relative abundances ‚Äî richness_from_abundances_gen","text":"","code":"if (FALSE) { # \\dontrun{ library(magrittr) library(purrr) data(\"Deru\") ToyData <- Deru taxa_assign_g <- assign_taxa(founder_object = ToyData) generations_simu <- holo_simu(h2 = 0.25, b2 = 0.25, founder_object = ToyData,                                n_clust = taxa_assign_g, n_ind = 500,                                verbose = FALSE, seed = 1234)                                 # Extract microbiomes matrix for each generations microbiomes <- generations_simu[-1] %>% map(get_microbiomes)   # Estimate diversity metrics richness_from_abundances <- microbiomes %>% map(richness_from_abundances_gen, size_rmultinom = 10000)  ## size_rmultinom = 10000 according to DeruPops dataset } # }"},{"path":"/reference/root.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute root value for beta matrix construction ‚Äî root","title":"Compute root value for beta matrix construction ‚Äî root","text":"function computes parameter used build beta matrix given correlation structure taxa. used beta matrix construction.","code":""},{"path":"/reference/root.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute root value for beta matrix construction ‚Äî root","text":"","code":"root(rho)"},{"path":"/reference/root.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute root value for beta matrix construction ‚Äî root","text":"rho numeric value 0 1 representing target correlation taxa within cluster. parameter used induce correlation beta matrix.","code":""},{"path":"/reference/select_individual.html","id":null,"dir":"Reference","previous_headings":"","what":"Obtain id of the parents selected for the next generation based on the criteria chosen by the user ‚Äî select_individual","title":"Obtain id of the parents selected for the next generation based on the criteria chosen by the user ‚Äî select_individual","text":"Obtain id parents selected next generation based criteria chosen user","code":""},{"path":"/reference/select_individual.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Obtain id of the parents selected for the next generation based on the criteria chosen by the user ‚Äî select_individual","text":"","code":"select_individual(   phenotypes,   microbiomes,   genotypes,   beta,   beta_otu,   selection,   size_selection_F,   size_selection_M,   selection_type,   size_rmultinom,   w.param )"},{"path":"/reference/select_individual.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Obtain id of the parents selected for the next generation based on the criteria chosen by the user ‚Äî select_individual","text":"phenotypes Phenotype values current generation given result combined effects microbiota direct genetic effects. Typically get_phenotypes() output compute_phenotypes(). microbiomes Abundances individual current generation. Note: necessary transform abundances CLR-transformed following command. microbiomes_clr |>  t() |> clrInv() |> t() genotypes Genotypes values current generation. Typically MoBPS get.geno() function. beta Beta matrix compute_beta_matrix_cluster() output. beta_otu Omega parameter calibrate_params_phenotypes() output. selection bool, selection process needed, DEFAULT = FALSE size_selection_F percentage female select. size_selection_M percentage male select. selection_type mode selection used, value (\"GB\", \"B\", \"G\", \"diversity\", \"div.GB\"), DEFAULT = \"GB\" size_rmultinom Integer; specifying total number object multinomial sampling(default: 10000, according DeruPop.rds dataset). w.param case div.GB selection mode chosen.","code":""},{"path":"/reference/transform_geno_into_vcf.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert a 0/1/2 genotype matrix into a VCF-like format ‚Äî transform_geno_into_vcf","title":"Convert a 0/1/2 genotype matrix into a VCF-like format ‚Äî transform_geno_into_vcf","text":"function converts genotype matrix encoded 0,1,2 VCF-like format. can either return VCF content data.frame, write .vcf file .","code":""},{"path":"/reference/transform_geno_into_vcf.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert a 0/1/2 genotype matrix into a VCF-like format ‚Äî transform_geno_into_vcf","text":"","code":"transform_geno_into_vcf(   geno_matrix,   output_type = c(\"file\", \"dataframe\", \"both\"),   output_path = NULL )"},{"path":"/reference/transform_geno_into_vcf.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert a 0/1/2 genotype matrix into a VCF-like format ‚Äî transform_geno_into_vcf","text":"geno_matrix matrix genotypes values 0, 1, 2. SNPs rows individuals columns. output_type character, specifies output type. Choose \"file\" (write .vcf), \"dataframe\" (return data.frame), \"\" (). output_path character string specifies output path. Requiered output_type \"file\" \"\".","code":""},{"path":"/reference/transform_geno_into_vcf.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert a 0/1/2 genotype matrix into a VCF-like format ‚Äî transform_geno_into_vcf","text":"data.frame output_type = \"dataframe\" \"\", just write .vcf file output_type = \"file\" \"\".","code":""},{"path":"/reference/transform_geno_into_vcf.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Convert a 0/1/2 genotype matrix into a VCF-like format ‚Äî transform_geno_into_vcf","text":"","code":"n_ind <- 50 n_snp <- 50  # Create a small genotype matrix set.seed(123) geno_matrix <- matrix(sample(0:2, size = n_ind*n_snp, replace = TRUE),                       nrow = n_snp, ncol = n_ind)  # Transform genotype matrix into VCF vcf <- transform_geno_into_vcf(geno_matrix, output_type = \"dataframe\") head(vcf[1:3,1:7]) #>   CHROM POS  ID REF ALT QUAL FILTER #> 1     1   1 rs1   A   T    .      . #> 2     1   2 rs2   A   T    .      . #> 3     1   3 rs3   A   T    .      ."},{"path":[]},{"path":"/news/index.html","id":"rithms-001","dir":"Changelog","previous_headings":"","what":"RITHMS 0.0.1","title":"RITHMS 0.0.1","text":"Initial CRAN submission.","code":""}]
