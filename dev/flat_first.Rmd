---
title: "flat_first.Rmd for working package"
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r}
knitr::opts_chunk$set(
  warning = FALSE,
  message = FALSE
)
```


<!-- Run this 'development' chunk -->
<!-- Store every call to library() that you need to explore your functions -->

```{r development, include=FALSE}
library(testthat)
```

<!--
 You need to run the 'description' chunk in the '0-dev_history.Rmd' file before continuing your code there.

If it is the first time you use {fusen}, after 'description', you can directly run the last chunk of the present file with inflate() inside.
--> 

```{r development-load}
# Load already included functions if relevant
pkgload::load_all(export_all = FALSE)
```

<!-- 
 Store your dataset in a directory named "inst/" at the root of your project.
 Use it for your tests in this Rmd thanks to `pkgload::load_all()` to make it available
and `system.file()` to read it in your examples.

- There already is a dataset in the "inst/" directory to be used in the examples below
-->

```{r development-dataset}
# Run all this chunk in the console directly
# There already is a dataset in the "inst/" directory
# Make the dataset file available to the current Rmd during development
pkgload::load_all(path = here::here(), export_all = FALSE)

# You will be able to read your example data file in each of your function examples and tests as follows - see chunks below
data("Deru")
ToyData <- Deru
```

# Pre-Simulation functions 

## Formatting data functions

```{r function-formatting_data}
#' Formatting data from file paths to base population object
#'
#' @importFrom data.table fread
#' @importFrom dplyr filter
#' @importFrom glue glue
#' @importFrom magrittr %>%
#'
#' @param path_to_microbiome String giving the path to count table file. `"path/to/microbiome.{extension}"`
#' @param path_to_genotype String giving the path and prefix to the genotype file. This should be one of `"pedmap"` or `"vcf"`. (default: `"pedmap"`), see `file_type` param. For a `"example_pedmap.ped"` file enter only `"path/to/example_pedmap"`.
#' @param file_type String specifying the file type used to load genotype data. This should be one of `"pedmap"` or `"vcf"`. (default: `"pedmap"`).
#' @param biome_id_column String specifying the name of the column containing the individual IDs for the microbiome matrix. Default is "ind_id".
#' @param threshold Threshold for rarefaction, DEFAULT = 0.05
#' @param ind_selected Vector of string values with individuals to keep, have to match rownames of count table file, DEFAULT = NULL
#' 
#' @return
#' A data.frame corresponding to (rarefied) microbiome with individuals in rows and taxa in columns. Genotypes data.frame is an attribute called "population" reachable using `attr(output_name,"population")`
#' 
#' @note
#' The number of individuals in the microbiome an genotype data must be equivalent.
#' 
#' @seealso [generate_founder()], [rarefied_microbiome()]
#' 
#' @rdname read_input_data
#' @export
read_input_data <- function(path_to_microbiome,
                            path_to_genotype,
                            file_type = "pedmap",
                            biome_id_column = "ind_id",
                            threshold = 0.05,
                            ind_selected = NULL){
  ########
  #read microbiome file and make genotypes and microbiome data match according to individuals
  ########
  microbiome <- data.table::fread(path_to_microbiome)
  microbiome_filtered5 <- rarefied_microbiome(microbiome, id_column = biome_id_column, threshold = threshold)
  if(!is.null(ind_selected)){
    microbiome_filtered5 <- microbiome_filtered5 %>% filter(rownames(.) %in% ind_selected)
  }
  
  if(!file_type %in% c("pedmap", "vcf")){
    print("The genotype file type must be one of 'pedmap' or 'vcf'.")
  } else {
    founder_object <- generate_founder(path = glue::glue("{path_to_genotype}"), microbiome_filtered5, file_type = file_type)

  }
  
  return(founder_object)
}

```

```{r example-formatting_data, message=FALSE, warning=FALSE}
\dontrun{
# Create founder object from PED/MAP set
founder_object <- read_input_data(path_to_microbiome = "/path/to/microbiome.txt",
                                  path_to_pedmap = "/path/to/pedmap/'prefix'",
                                  biome_id_column = "ind_id",
                                  threshold = 0.05,
                                  ind_selected = NULL,
                                  file_type = "pedmap")

# Create founder object from VCF
founder_object <- read_input_data(path_to_microbiome = "/path/to/microbiome.txt",
                                  path_to_pedmap = "/path/to/vcf/'prefix'",
                                  biome_id_column = "ind_id",
                                  threshold = 0.05,
                                  ind_selected = NULL,
                                  file_type = "vcf")
}
```

```{r function-rarefied_microbiome}
#' Rarefaction step within read_input_data
#' 
#' @importFrom tibble as_tibble column_to_rownames tibble
#' @importFrom dplyr rename filter pull
#' @importFrom MoBPS creating.diploid
#' @importFrom magrittr %>%
#' 
#' @inheritParams read_input_data
#' 
#' @param microbiome_matrix Microbiome counting table, OTUs in columns and a column specifying the IDs
#' @param id_column String specifying the name of the column containing the individual IDs. Default is "ind_id"
#' @param threshold Minimum prevalence threshold
#' 
#' @return
#' The filtered microbiome matrix, without OTUs whose prevalence is lower than the set threshold
#' 
#' @seealso [read_input_data()], [generate_founder()]
#' 
#' @rdname rarefied_microbiome

rarefied_microbiome <- function(microbiome_matrix,
                                id_column = "ind_id",
                                threshold = 0.05){
  microbiome_matrix <- microbiome_matrix |> as_tibble() |> column_to_rownames(var = id_column)
  abundant_otus <- tibble(
    V1         = colnames(microbiome_matrix),
    prevalence = colMeans(microbiome_matrix > 0)
  ) |> rename(OTU = V1) |> filter(prevalence >= threshold) |> pull(OTU)
  return(microbiome_matrix[, abundant_otus])
}
```

```{r examples-rarefied_microbiome}
\dontrun{
  microbiome <- data.table::fread("/path/to/microbiome.txt")
  microbiome_filtered <- rarefied_microbiome(microbiome, id_columns = "sample_id", threshold = 0.05)
}
```

```{r function-generate_founder}
#' Formatting of ped/map files or vcf into haplotypes table and create it as "population" attr.
#' 
#' @param path String giving the path and prefix to ped and map file
#' @param microbiome_matrix Filtered microbiome matrix, with OTUs in columns and individuals in rows
#' @param file_type String specifying the file type used to load genotype data. This should be one of `"pedmap"` or `"vcf"`. (default: `"pedmap"`).
#' 
#' @return 
#' Matrix of taxa (in columns) accross individuals (in rows), genotypes of each generation are reachable thanks to **"population"** attribute. Genotypes are encodes as 0,1,2 and generated using the [MoBPS](https://pubmed.ncbi.nlm.nih.gov/32229505/) package.
#' 
#' @seealso [read_input_data()], [rarefied_microbiome()]
#' 
#' @rdname generate_founder


generate_founder <- function(path = NULL,
                             microbiome_matrix, file_type = "pedmap"){
  # # Convert PED-file into haplotype dataset (one haplotype per colum)
  if(is.null(path)){
    stop("path must be a valid string like : '/path/to/directory/prefix")
  }else{
    if(file_type == "pedmap"){
      if(FALSE %in% file_test("-f", c(glue("{path}.ped"), glue("{path}.map")))){
        stop(glue("Files {path}.ped and/or {path}.map don't exist, please check your path argument"))
      }else{
        map <- as.matrix(read.table(glue("{path}.map")))
        ped <- as.matrix(read.table(glue("{path}.ped")))
        
        #Step to filter ped map based on microbiome matrix,
        #rownames microbiote_matrix must be ind ID to match column 2 of ped file
        # ped_ind <- ped[,2] %>% gsub("\\s","",.)
        # microbiote_ind <- rownames(microbiote_matrix)
        # microbiote_filtered <- microbiote_matrix[microbiote_ind %in% ped_ind,]
        # ped <- ped[ped_ind %in% microbiote_ind,]
        ####
        nsnp <- (ncol(ped)-6)/2
        haplo1 <- ped[,1:nsnp*2+6-1] #all odd numbers
        haplo2 <- ped[,1:nsnp*2+6] #all uneven numbers
        haplo <- t(rbind(haplo1, haplo2)[c(0,nrow(haplo1)) + sort(rep(1:nrow(haplo1),2)),])
        #haplo <- ifelse(haplo == "0", NA,haplo)
        population <- creating.diploid(dataset = haplo, map = map, verbose=TRUE)
        
      }
    } else if(file_type == "vcf"){
        path_to_vcf <- glue("{path}.vcf")
        population <- creating.diploid(vcf = path_to_vcf, verbose=TRUE)
        
    }
      
      attr(microbiome_matrix,"population") <- population
      return(microbiome_matrix)
    }
  
}


```

```{r examples-generate_founder}
\dontrun{
  microbiome <- data.table::fread("/path/to/microbiome.txt")
  founder_object <- generate_founder(path = "/path/to/pedmap", microbiome) 
}

```


## Taxa assignation function

```{r function-assign_taxa}
#' Assign all taxa to a cluster, eventually under genetic control using hclust
#'
#' @param founder_object Output of read_input_data function
#' @param taxa_g Percentage of taxa under genetic control, DEFAULT = 0.1
#' 
#' @importFrom vegan vegdist
#' @importFrom glue glue
#' @importFrom magrittr %>%
#'
#' @return
#' A vector with a length matching the total number of taxa with values from 0 to the number of clusters, 0 corresponding to the non under genetic control cluster
#' @rdname formatting_data
#' @export

assign_taxa <- function(founder_object,
                        taxa_g = 0.05){
  dist_mat <- vegdist(x = t(founder_object),
               method = "bray")
  hc <- hclust(dist_mat)
  taxa_assign <- cutree(hc, k = 100)
  ntaxa_g = 0
  cluster_id_g = c()
  if(sum(table(taxa_assign)[table(taxa_assign) > 10 & table(taxa_assign) < 25]) < round(length(taxa_assign)*taxa_g)){
    print(glue("{sum(table(taxa_assign)[table(taxa_assign) > 10 & table(taxa_assign) < 25])} taxa available for genetic control sampling but {round(length(taxa_assign)*taxa_g)} asked. Change taxa_g parameter please."))
  }
  while(ntaxa_g < round(length(taxa_assign)*taxa_g)){
    new_id <- table(taxa_assign)[table(taxa_assign) > 10 & table(taxa_assign) < 25] %>% sample(1) %>% names() %>% as.numeric()
    if(! new_id %in% cluster_id_g){
      cluster_id_g <- append(cluster_id_g, new_id)
      ntaxa_g <- ntaxa_g + sum(taxa_assign == new_id)
    }
  }
  taxa_assign_g <- ifelse(taxa_assign %in% cluster_id_g, taxa_assign, 0) %>% as.factor()
  levels(taxa_assign_g) <- c(0:length(cluster_id_g))
  return(taxa_assign_g)
}

```

```{r examples-assign_taxa, message=FALSE, warning=FALSE}
data("Deru")
ToyData <- Deru
taxa_assign_g <- assign_taxa(founder_object = ToyData,
            taxa_g = 0.2)
```

```{r tests-assign_taxa}
#test length of assignment vector
```

## Calibration of genetic effect

```{r function-gen_effect_calibration}
#' Calibration of genetic effect from founder population data 
#'
#' @importFrom compositions clr 
#' @importFrom MoBPS get.geno
#' @importFrom ggplot2 ggplot geom_boxplot labs theme aes element_text element_rect element_line
#' @importFrom ggridges geom_density_ridges
#' @importFrom glue glue
#' @importFrom magrittr %>%
#' 
#' @param founder_object Output of generate_founder() function
#' @param taxa_assign_g Factor vector giving cluster assignment for all taxa, typical output of assign_taxa()
#' @param correlation Correlation between taxa within the same cluster, value between 0 and 1, DEFAULT = 0.5
#' @param effect.size Vector giving the size of genetic effect to try 
#' @param plot boolean, if plot generation is required, DEFAULT = TRUE
#' 
#' @return
#' A data.frame with three columns, giving the Taxa ID, the effect.size and the corresponding heritability
#' 
#' @rdname gen_effect_calibration
#' @export
gen_effect_calibration <- function(founder_object,
                                   taxa_assign_g,
                                   correlation = 0.5,
                                   effect.size = c(seq(0.1,1,0.1)),
                                   plot = T){
  #init of all parameters
  
  #Microbiome part
  M <- founder_object %>% t() %>% apply(2, \(x) x/sum(x))
  M0_clr <- M |> t() |> clr() |> t()
  taxa_scale <- apply(M0_clr, 1, sd)
  #Genotype
  G <- get.geno(attr(founder_object,"population"),gen=1)
  
  #beta arguments
  n_g <- nrow(G)
  n_clust_g <- taxa_assign_g[taxa_assign_g != 0] %>% unique() %>% length()
  n_qtl_o <- ((n_g * 0.2)/n_clust_g)  %>% round()
  
  #output variables 
  out_data <- data.frame()
  
  #One run to obtain beta info matrix 
  beta_innit <- compute_beta_matrix_cluster(n_b = nrow(M), 
                                            n_g = n_g, 
                                            n_clust = taxa_assign_g, 
                                            n_qtl_o = n_qtl_o, 
                                            n_otus = sum(taxa_assign_g != 0), 
                                            correlation = correlation, 
                                            effect_size = 0.1)
  
  beta_info <- attr(beta_innit, "sim_params")
  
  for(e in effect.size){
    beta <- compute_beta_matrix_cluster(n_b = nrow(M), 
                                        n_g = n_g, 
                                        n_clust = taxa_assign_g, 
                                        n_qtl_o = n_qtl_o, 
                                        n_otus = sum(taxa_assign_g != 0), 
                                        correlation = correlation, 
                                        effect_size = e,
                                        beta_info = beta_info)
    beta_test <- attr(beta, "sim_params")
    #print(beta_test$id_otu[1])
    betaG_e <- compute_beta_g(beta, G, noise = 0.5, taxa_scale = taxa_scale)
    betaG <- attr(betaG_e,"noise")$betag
    betag_var <- betaG |> apply(1,var)
    
    M_sim <- M0_clr + betaG_e
    M_var <- apply(M_sim,1,var)
    
    out_data <- rbind(out_data,cbind(Taxa = names(M_var[betag_var != 0]), effect.size = e, Heritability = (betag_var[betag_var != 0] / M_var[betag_var != 0])))
  }
  
  out_data$effect.size <- as.numeric(out_data$effect.size)
  out_data$Heritability <- as.numeric(out_data$Heritability)
  
  if(plot){
    p <- out_data %>% ggplot(aes(x = as.factor(effect.size),y=Heritability, fill = as.factor(effect.size))) +
      geom_boxplot()+
      labs(title = glue("Heritabilities distribution"),
           subtitle = glue("({length(unique(out_data$Taxa))} taxa under genetic control)"),
           x = "Genetic effect size") +
      theme(panel.background = element_rect(fill="white"),
            panel.grid.major = element_line(colour="#e3e3e3"),
            panel.grid.minor = element_line(colour="#e9e9e9"),
            axis.title = element_text(size = 12),
            axis.text = element_text(size=9),
            plot.title = element_text(size=12),
            aspect.ratio = 1.5,
            legend.position = "none")
    print(p)
    
    p2 <- out_data %>% ggplot(aes(x=Heritability,y=as.factor(effect.size),fill=as.factor(effect.size))) +
      geom_density_ridges(alpha=0.8)+
      labs(title = "Ridges plot of taxa heritability",
           x = "Taxa heritability",
           y = "Genetic effect size")+
      theme(legend.position = "none",
            panel.background = element_rect(fill="white"),
            panel.grid.major = element_line(colour="#e3e3e3"),
            panel.grid.minor = element_line(colour="#e9e9e9"),
            axis.title = element_text(size = 12),
            axis.text = element_text(size=9),
            plot.title = element_text(size=12),
            aspect.ratio = 1.5)
    print(p2)
  }
  return(out_data)
}
```

```{r examples-gen_effect_calibration, message=FALSE, warning=FALSE}
data("Deru")
ToyData <- Deru
taxa_assign_g <- assign_taxa(founder_object = ToyData)
effect_size_vector <- c(seq(0.1,1, by = 0.2))
out_data <- gen_effect_calibration(founder_object = ToyData,
                                   taxa_assign_g = taxa_assign_g,
                                   correlation = 0.5,
                                   effect.size = effect_size_vector,
                                   plot = TRUE)
```

```{r tests-genetic_effect}
```

```{r function-compute_beta_matrix_cluster}
#' Generate beta matrix giving genetic effect per SNP on taxa abundances.
#' @importFrom glue glue
#' @importFrom tibble tibble
#' @importFrom purrr map
#' @importFrom magrittr %>%
#' 
#' @inheritParams gen_effect_calibration
#' 
#' @param n_b Number of taxa
#' @param n_g Number of SNPs
#' @param n_clust A vector with a length matching the total number of taxa with values from 0 to the number of clusters. Typically the [assign_taxa()] output.
#' @param n_qtl_o Number of causative QTL on taxa abundances (per taxon)
#' @param n_otus Number of taxa under genetic control.
#' @param effect_size Vector giving the size of genetic effect to try
#' @param correlation A numeric value between 0 and 1 representing the target correlation between taxa within the same cluster.
#' @param beta_info Informations from Beta matrix of genetic effects
#' 
#' @return A `matrix` of taxa (in rows) across SNPs (in columns) giving the multiplicative effect of genotype on taxa abundances.
#' 
#' @seealso [compute_beta_g()], [holo_simu()]
#' 
#' @rdname compute_beta_matrix_cluster

compute_beta_matrix_cluster <- function(n_b,
                                        n_g,
                                        n_clust,
                                        n_qtl_o,
                                        n_otus, #percentage
                                        effect_size = 1,
                                        correlation = 1, ## value between 0 and 1
                                        beta_info = NULL
){
  # Initialisation of beta matrix of genetic effects
  beta <- matrix(0, nrow = n_b, ncol = n_g, 
                 dimnames = list(
                   glue('OTU_{1:n_b}'), 
                   glue('SNP_{1:n_g}') 
                 ))
  
  nb_k <- (n_clust[n_clust != 0] %>% unique() %>% length())  
  
  if(is.null(beta_info)){
    beta_info <- tibble(
      cluster     = 1:nb_k,
      id_otu      = split(1:length(n_clust), n_clust)[-1],
      id_qtl_o    = map(cluster, \(x) {sample(1:n_g, n_qtl_o)})
    )
  }
  sd_factor <- effect_size / sqrt(n_qtl_o)
  for(clus in 1:nb_k){
    # Extract causal SNPs for current cluster
    id_qtl_o <- beta_info[["id_qtl_o"]][clus][[1]]
    # Extract OTUs under genetic control for current cluster
    ID_OTUs_gen <- beta_info[["id_otu"]][clus][[1]]
    # fill beta with random variable 
    # TODO: should the effect of a SNP be shared across OTU in a cluster ?
    # to create blockwise effect in beta G ? 
    lambda <- root(correlation)
    ind_coef         <- rnorm(length(ID_OTUs_gen) * n_qtl_o, mean = 0, sd = sd_factor)
    correlated_coef  <- matrix(rnorm(n_qtl_o, 0, sd_factor), 
                               nrow = length(ID_OTUs_gen), ncol = n_qtl_o,
                               byrow = TRUE)
    beta[ID_OTUs_gen,id_qtl_o] <- (lambda * correlated_coef + (1 - lambda) * ind_coef) / sqrt(lambda^2 + (1-lambda)^2)
  }
  
  attr(beta, "sim_params") <- beta_info
  return(beta)
}

```

```{r function-compute_beta_g}
#' Compute product of matrixes based on few parameters
#' 
#' This function compute the product between the matrix of OTUs-specific genetic effects and the matrix of genotypes. 
#' This is part of [gen_effect_calibration()], where individual_level effects of genotypes on taxa are computed.
#' 
#' @importFrom magrittr %>%
#'
#' @param beta A `matrix` of taxa (in rows) across SNPs (in columns) giving the multiplicative effect of genotype on taxa abundances. Typically obtained from [compute_beta_matrix_cluster()].
#' @param genotypes A `matrix` of genotypes with SNPs in rows and individuals in columns.
#' @param noise A `numeric` scalar indicating the standard deviation of the Gaussian noise to add.
#' @param taxa_scale A `numeric` scalar to scale the noise added to each OTUs abundance.
#' 
#' @seealso [gen_effect_calibration()]

#' @return A `matrix` with taxa in roxs and individuals in columns, where each element represents the abundance of a given taxa in an individual, influenced by the genotype.
#' 
#' @rdname compute_beta_g
compute_beta_g <- function(beta,
                           genotypes,
                           noise,
                           taxa_scale){
  G <- genotypes
  beta_g_tmp <- beta %*% G
  beta_g <- beta_g_tmp %>% t() %>% scale(center=TRUE,scale=FALSE) %>% t() 
  beta_g_raw <- beta_g
  noise_vec = rnorm(n = nrow(beta) * ncol(G), sd = noise) * taxa_scale
  beta_g <-  beta_g_raw + noise_vec
  attr(beta_g,"noise") <- list('noise' = noise_vec,'betag' = beta_g_raw)
  return(beta_g)
}
```

```{r examples-compute_beta_g}
set.seed(123)
n_taxa <- 5
n_snp <- 10
n_ind <- 50
# Simulate a little beta matrix
beta <- matrix(sample(seq(0.1, 1, by = 0.05), size = n_taxa*n_snp, replace = TRUE), nrow = n_taxa, ncol = n_snp)

# Simulate a little genotype matrix
genotypes <- matrix(sample(0:2, size = n_snp*n_ind, replace = TRUE), nrow = n_snp, ncol = n_ind)

# Compute beta_g matrix with noise
beta_g <- RITHMS:::compute_beta_g(beta = beta,
                                  genotypes = genotypes,
                                  noise = 0.05,
                                  taxa_scale = 1)
```

```{r function-root}
#' Compute root value for beta matrix construction
#' 
#' This function computes the parameter used to build a beta matrix with a given correlation structure between taxa. It is used in the beta matrix construction.
#' 
#' @param rho A numeric value between 0 and 1 representing the target correlation between taxa within the same cluster. This parameter is used to induce correlation in the beta matrix.
#' @rdname root
#' 
root <- function(rho) {
  if (rho == 0.5) return(0.5)
  (2 * rho - sqrt(4 * rho^2 - 4 * rho * (2* rho - 1))) / (4*rho - 2)
}
``` 

# HoloSimu
## Useful functions 

```{r function-calibrate_params_phenotypes}
#' Calibration coefficients to compute phenotypes
#' 
#' This function is part of the first step of [holo_simu()], focused on calibrating phynotypes parameters before looping on the generations. All coefficents are rescale during the process to ensure that standard deviation = 1 and the variance of microbiote effect and genetic effect satisfy the target microbiability and direct heritability.
#' 
#' @inheritParams holo_simu
#' 
#' @param X0 Matrix of the primary generation genotypes, given from \link[MoBPS:get.geno]{get.geno()} MoBPS function. SNPs are in rows and individuals in columns.
#' @param B0 Matrix of the primary generation microbiomes, as CLR abundances. OTUs are in rows and individuals in columns.
#' @param otu_list List of causal OTUs for the phenotypes.
#' @param Nqtl_y Integer; number of causal SNPs for the phenotypes.
#' @param Notu_y Integer; number of causal OTUs for the phenotypes.
#' 
#' @examples
#' library(magrittr)
#' n_ind <- 10
#' n_snp <- 50
#' n_otu <- 50
#' 
#' # Simulate a small genotype matrix 
#' set.seed(123)
#' X0 <- matrix(sample(0:2, n_snp * n_ind, replace = TRUE), nrow = n_snp, ncol = n_ind)
#' 
#' # Simulate a small microbiome counts matrix
#' B0_counts_table <- matrix(abs(rnorm(n_snp * n_ind, mean = 10, sd = 3)), nrow = n_otu, ncol = n_ind)
#' 
#' # Transform to relative abundances per individuals and then apply CLR transformation
#' B0_abund <- apply(B0_counts_table, 2, function(x) x/sum(x))
#' B0 <- compositions::clr(t(B0_abund)) %>% t()
#' 
#' # Randomly select causal OTUs
#' rownames(B0) <- paste0("OTU", 1:n_otu)
#' otu_list <- c(y = sample(rownames(B0), 10))
#' 
#' 
#' params <- suppressWarnings(RITHMS:::calibrate_params_phenotypes(X0 = X0,
#'                                       B0 = B0,
#'                                       h2 = 0.25,
#'                                       b2 = 0.25,
#'                                       otu_list = otu_list,
#'                                       Nqtl_y = 10,
#'                                       Notu_y = length(otu_list)))
#' str(params)
#'  
#' @return A `list` of phenotype parameters such as alpha, omega, list of causal SNPs for the phenotypes, standard deviation (=1) of phenotypes
#' 
#' @seealso [compute_phenotypes()]
#' @rdname calibrate_params_phenotypes

calibrate_params_phenotypes <- function(X0,
                                        B0,
                                        h2,
                                        b2,
                                        otu_list,
                                        Nqtl_y,
                                        Notu_y = length(otu_list)){
  if (Notu_y == 0) b2 = 0
  if (Nqtl_y == 0) h2 = 0
  
  ## heritability and microbiability should be non-negative and the sum should be positive
  stopifnot(h2 >= 0, b2 >= 0, h2 + b2 > 0)
  
  #init 
  Nind = ncol(X0)
  Nsnp = nrow(X0)
  Notu = nrow(B0)
  Bclust=seq(Notu)
  Nclust = max(Bclust)
  gb = rep(0,Nind)
  gq = gb
  
  ## list of snps directly influencing y :
  qtl_list  = sample(seq(Nsnp), size = Nqtl_y)
  beta_qtl = rgamma(Nqtl_y, shape = 0.4, scale = 5) * sample(c(1,-1), size=Nqtl_y, replace = T)
  beta_otu = rgamma(Notu_y, shape = 1.4, scale = 3.8) * sample(c(1,-1), size = Notu_y, replace = T)
  
  # OTU part  
  if(Notu_y>0){ #arrow from B to y
    B <- as.matrix(B0)
    gb = t(B[otu_list, , drop = FALSE]) %*% beta_otu
    varb <- var(gb)
  }
  
  ## If not genetic effect:
  ## - no scaling for microbiote parameters
  ## - scale noise variance using microbiote as a reference
  if (h2 == 0) {
    
    ## genetic effects
    beta_qtl[] <- 0
    gq <- rep(0, Nind)
    
    ## noise scaling
    se <- sqrt(varb * (1-b2) / b2)
  } else {
    ## Scale microbiote and noise variance using genetic effects as reference
    
    ## genetic effects
    stopifnot(Nqtl_y > 0) ## Nqtl_y should be positive if h2 > 0
    X <- as.matrix(X0)
    gq = t(X[qtl_list, , drop = FALSE]) %*% beta_qtl
    varg <- var(gq)
    
    ## microbiote and noise scaling
    microbiote_scaling <- sqrt( (b2 * varg) / (h2 * varb) )
    beta_otu[] <- microbiote_scaling * beta_otu
    se <- sqrt(varg * (1- h2 - b2) / h2)
  }
  
  ## Rescale all coefficents to ensure that se = 1 and the variances of gb and gq satisfy the 
  ## target microbiability and "heritability" 
  return(list('alpha' = beta_qtl / c(se), 
              'omega' = beta_otu / c(se),
              'qtl_list' = qtl_list,
              'se' = se / se ## = 1
  ))
}

```

```{r function-compute_phenotypes}

#' Compute phenotype values based on generated objects of the current generation
#'
#' @param X A `matrix` of the current generation genotypes, encoding with 0, 1 and 2.
#' @param B A `matrix` of the CLR-transformed abundances of the current generation microbiome.
#' @param otu_list List of causal OTUs for the phenotypes.
#' @param qtl_list List of causal SNPs for the phenotypes.
#' @param beta_qtl Alpha, the regression coefficients corresponding to the QTL effects on the phenotype. See [calibrate_params_phenotypes()].
#' @param beta_otu Omega, the regression coefficients corresponding to taxa effects on the phenotype. See [calibrate_params_phenotypes()].
#' @param Nqtl_y Integer, number of causal SNPs for the phenotypes.
#' @param Notu_y Integer, number of causal OTUs for the phenotypes.
#' @param se Phenotypes Standard deviation, see [calibrate_params_phenotypes()].
#' 
#' @seealso [calibrate_params_phenotypes()]
#' @rdname compute_phenotypes

compute_phenotypes <- function(X,     #Genotypes matrix with 0,1,2 encoding
                               B,     #Microbiome matrix, CLR abundances
                               otu_list,
                               qtl_list, 
                               beta_qtl,
                               beta_otu,
                               Nqtl_y,
                               Notu_y,
                               se){
  
  # SNP part
  if (Nqtl_y>0) { #arrow from G to y
    #print(beta_qtl %>% head())
    X <- as.matrix(X)
    gq = t(X[qtl_list,]) %*% beta_qtl
  }
  
  # OTU part  
  if(Notu_y>0){ #arrow from B to y
    #print(beta_otu %>% head())
    B <- as.matrix(B)
    Botu = B[otu_list,]
    gb = t(Botu) %*% beta_otu
  }
  
  y = gq + gb + rnorm(length(gq), 0, se)
  return(list('y'=y, 'gq'=gq, 'gb'=gb))
  
}
```

```{r function-compute_mean_microbiome}
#' Compute the mean for each taxa across population
#'
#' This function estimate the mean microbiome by averaging abundances across individuals for each taxa. Optionally, 
#' it use a Dirichlet distribution to simulate inter-individual variability centered arround the mean.
#' 
#' @importFrom bazar stopif
#' @importFrom dirmult rdirichlet
#' @importFrom magrittr %>%
#' 
#' @param microbiome A `matrix` of microbiome abundances (taxa in rows, individuals in columns).
#' @param dir A `logical`; if `TRUE`, use a Dirichlet distribution to simulate inter-individual variability. Default is `FALSE`.
#' @param n_ind The number of individuals to simulate with the Dirichlet distribution (required if `dir = TRUE`).
#' @param ao A numeric scalar used as the concentration parameter for the Dirichlet distribution.
#' @param mix.params A numeric vector (`length = 2`) specifying weights between Dirichlet samples and the original mean. The weigths should sum to 1.
#' 
#' @return
#' A `numeric`vector of mean microbiome values if `dir = FALSE`.
#' A `matrix` of simulated microbiomes if `dir = TRUE`
#' 
#' @seealso [compute_current_microbiome()]
#' @rdname compute_mean_microbiome

compute_mean_microbiome <- function(microbiome, dir = F, n_ind = NULL, ao, mix.params){
  mean_microbiome <- rowMeans(microbiome)
  if(dir){
    stopif(is.null(n_ind))
    dir_mean <- rdirichlet(n_ind,as.numeric(mean_microbiome)*ao) %>% t()
    mix_mean <- (mix.params[1] * dir_mean + mix.params[2] * matrix(mean_microbiome,nrow=nrow(dir_mean),ncol=ncol(dir_mean),byrow=F))
    attr(mix_mean, "dirichlet") <- dir_mean
    return(mix_mean)
  }else{
    mean_microbiome
  }
}
```

```{r function-compute_current_microbiome}
#' Compute microbiomes for all individuals of current generation gathering all relevant object already computed.
#' 
#' @importFrom compositions clr
#' @importFrom magrittr %>%
#' 
#' @param beta A `matrix` of taxa (rows) by SNPs (columns) representing the multiplicative effect of SNPs on taxa abundances. Typically the output of [compute_beta_matrix_cluster()]
#' @param current_genotypes A `matrix` of genotypes for the individuals of the current generation.
#' @param mother_microbiomes A `matrix` containing the CLR-transformed abundances from the microbiome of the current mothers.
#' @param mean_microbiome A `numeric` vector representing the average abundances of the microbiome within the population.
#' @param noise A `numeric` scalar indicating the standard deviation of the Gaussian noise to add during beta g construction [compute_beta_g()](multiplicative genetic effect on taxa abundances).
#' @param taxa_scale A `numeric` scalar to scale the noise added to each OTUs abundance, see [compute_beta_g()].
#' @param lambda A `numeric` between 0 and 1 controlling the relative contribution of the mother microbiome compared to the average microbiome.
#' @param dir A `logical`;
#' @param thetaX A `matrix` representing the environmental effect (optional).
#' 
#' @return A `matrix` of CLR-transformed abundances of the microbiome for each individual of the current generation.
#' 
#' @seealso [compute_mean_microbiome()]
#' @rdname compute_current_microbiome 

compute_current_microbiome <- function(beta,
                                       current_genotypes,
                                       mother_microbiomes,
                                       mean_microbiome,
                                       noise=0.1,
                                       taxa_scale, 
                                       lambda=0.5,
                                       dir = F,
                                       thetaX){
  
  beta_g_eps <- compute_beta_g(beta = beta, genotypes = current_genotypes, noise = noise, taxa_scale = taxa_scale)
  if(dir){
    internal_compute <- lambda*(mother_microbiomes) + (1-lambda)*mean_microbiome
  }else{
    internal_compute <- lambda*(mother_microbiomes) + (1-lambda)*matrix(mean_microbiome,nrow=nrow(beta_g_eps),ncol=ncol(beta_g_eps),byrow=F)
  }
  #TODO : check dimensions of thetaX
  if(!is.null(thetaX)){
    microbiome <- t(clr(t(internal_compute)%>% replace_zero())) + beta_g_eps + thetaX
  }else{
    microbiome <- t(clr(t(internal_compute)%>% replace_zero())) + beta_g_eps
  }
  colnames(microbiome) <- colnames(beta_g_eps)
  
  attr(microbiome,"noise_microbiome") <- list('attr'=attr(beta_g_eps,"noise"), 
                                              'clr_mic' = t(clr(t(internal_compute)%>% replace_zero())),
                                              'env_eff' = thetaX)
  #return CLR(microbiome)
  return(microbiome)
}
```

```{r function-replace_zero}
#' Replace zero in the matrix by 1e-15 to avoid infinite values when CLR transformation is computed
#' 
#' @importFrom compositions oneOrDataset is.NMV
#' 
#' @param x A matrix
#' @export
replace_zero <- function(x){
  W <- oneOrDataset(x)
  nmv <- is.NMV(W)
  ifelse(nmv, W, 1e-15)
}
```

```{r function-select_individual}
#' Obtain id of the parents selected for the next generation based on the criteria chosen by the user
#' 
#' @importFrom magrittr %>%
#' @importFrom dplyr select
#' @importFrom stringr str_extract
#' 
#' @param phenotypes Phenotype values of the current generation given as the result of the combined effects of the microbiota and direct genetic effects. Typically [get_phenotypes()] output or [compute_phenotypes()].
#' @param microbiomes Abundances for each individual of the current generation. Note: It is necessary to transform the abundances if they are CLR-transformed with the following command. `microbiomes_clr |>  t() |> clrInv() |> t()`
#' @param genotypes Genotypes values of the current generation. Typically from the MoBPS `get.geno()` function.
#' @param beta Beta matrix from [compute_beta_matrix_cluster()] output.
#' @param beta_otu Omega parameter from [calibrate_params_phenotypes()] output.
#' 
#' @inheritParams holo_simu
#' @rdname select_individual

select_individual <- function(phenotypes,
                              microbiomes,
                              genotypes,
                              beta,
                              beta_otu,
                              selection, 
                              size_selection_F, 
                              size_selection_M, 
                              selection_type,
                              size_rmultinom,
                              w.param){
  #extract id of individuals of interest
  n_F <- (size_selection_F * length(grep("^F",colnames(genotypes)))) |> round()
  n_M <- (size_selection_M * length(grep("^M",colnames(genotypes)))) |> round()
  
  #being able to select between GB, B, G, diversity or diversity + GB
  if(selection){
    ######
    #Few tests on parameters values
    #####
    if(is.null(size_selection_F) || is.null(size_selection_M)){
      print("Please check you provided size_selection_F and size_selection_M argument (int) for selection step")
    }
   if(!selection_type %in% c("GB", "B", "G", "diversity", "div.GB")){
     print("Selection type must be one of 'GB', 'B', 'G', 'diversity' or 'div.GB'")
   }
    if(selection_type == "GB"){
      score <- phenotypes$gq + as.vector(beta_otu %*% (beta[rowSums(beta) != 0, ] %*% genotypes))
      #score <- phenotypes$gq + as.vector((beta[rowSums(beta) != 0, ] %*% genotypes))
      #score <- phenotypes$gq + phenotypes$gb
    }else if(selection_type == "G"){
      score <- phenotypes$gq
    }else if(selection_type == "B"){
      score <- phenotypes$gb
    }else if(selection_type == "diversity"){
      score <- microbiomes %>% richness_from_abundances_gen(size_rmultinom = size_rmultinom) %>% select(Shannon) %>% as.matrix()
    }else{
      diversity <- microbiomes %>% richness_from_abundances_gen(size_rmultinom = size_rmultinom) %>% select(Shannon) %>% as.matrix()
      TBV <- phenotypes$gq + as.vector(beta_otu %*% (beta[rowSums(beta) != 0, ] %*% genotypes))
      score = w.param[1] * diversity + w.param[2] * TBV
    }
    
    #extract individuals ID
    F_id <- score[grep("^F",rownames(score)),] %>% sort(decreasing = T) %>% names() %>% str_extract("[0-9]+") %>% head(n_F)
    M_id <- score[grep("^M",rownames(score)),] %>% sort(decreasing = T) %>% names() %>% str_extract("[0-9]+") %>% head(n_M)
    
  }else{
    if(!is.null(size_selection_F) || !is.null(size_selection_M)){
      print("Warning : Selection is set to False but size_selection_F or size_selection_M is not NULL")
    }
    
    n_F <- (0.3 * length(grep("^F",colnames(genotypes)))) |> round()
    n_M <- (0.3 * length(grep("^M",colnames(genotypes)))) |> round()
    #extract individuals ID
    F_id <- colnames(genotypes)[grep("^F",colnames(genotypes))] %>% str_extract("[0-9]+") %>% sample(n_F)
    M_id <- colnames(genotypes)[grep("^M",colnames(genotypes))] %>% str_extract("[0-9]+") %>% sample(n_M)
  }

  return(list(F_id = F_id, M_id = M_id))
}
```

## Main function

```{r function-holo_simu}
#' Main function to generate transgenerational hologenomic data
#' 
#' @description Simulates hologenomic data over multiple generations with genetic, microbial, and environmental effects.
#'
#' @importFrom MoBPS get.geno breeding.diploid get.pedigree
#' @importFrom compositions clr clrInv
#' @importFrom glue glue
#' @importFrom phyloseq phyloseq estimate_richness otu_table
#' @importFrom purrr list_c
#' @importFrom magrittr %>%
#' 
#' @param h2 direct heritability value, between 0 and 1. 
#' @param b2 microbiability value, between 0 and 1.
#' @param founder_object output of `generate_founder()` function.
#' @param n_ind number of individual per generation.
#' @param n_clust vector with taxa assignment, typical output of `assign_taxa()`
#' @param n_gen number of generation, DEFAULT = 5
#' @param qtn_y number of causal SNPs for the phenotypes.
#' @param correlation Correlation between taxa within the same cluster, value between 0 and 1, DEFAULT = 0.5
#' @param otu_g percentage of taxa under genetic control, between 0 and 1, DEFAULT = 0.05
#' @param lambda proportion of microbiome of offspring coming from vertical transmission, DEFAULT = 0.5
#' @param effect.size Vector giving the size of genetic effect to try.
#' @param mix.params Vector of two numeric values giving the weights for the regularisation of the base population microbiome. `mix.params[1]` = weight for raw microbiome and `mix.params[2]` = weight for mean microbiome. DEFAULT = c(0.75,0.25).
#' @param mix.params.M A vector of two numeric values specifying weights between Dirichlet samples and the original mean. DEFAULT = c(0.75,0.25). With `mix.params.M[1]` the dirichlet microbiome coefficient and `mix.params.M[2]` the mean microbiome coefficient.
#' @param noise.microbiome sd of microbiome noise, DEFAULT = 0.1
#' @param dir Logical; Mentions if the ambient microbiome is generated via a Dirichlet law or a only the `mean_microbiome`. DEFAULT = T
#' @param ao A numeric scalar used as the concentration parameter for the Dirichlet distribution.
#' @param size_rmultinom Integer; specifying the total number of object for the multinomial sampling(default: 10000, according to DeruPop.rds dataset).
#' @param selection bool, if selection process needed, DEFAULT = FALSE
#' @param size_selection_F percentage of female to select.
#' @param size_selection_M percentage of male to select.
#' @param selection_type mode of selection to be used, value in ("GB", "B", "G", "diversity", "div.GB"), DEFAULT = "GB"
#' @param w.param in case div.GB selection mode is chosen.
#' @param thetaX Optionnal matrix specifying environmental effects applied to the microbiome, such as antibiotic treatment. This matrix should be of dimension `n_taxa x n_individuals`, and typically constructed as the product of:
#' - a vector of taxa-specific effects `theta` (negative or positive values for all taxa).
#' - a binary vector `X` encoding individual exposure (1 for treated, 0 ofr untreated).
#' If `NULL` (default value), no environmental effect is applied.
#' Example use case: refer to the vignette on [Generate figures](https://solenepety.github.io/RITHMS/articles/generate-figures.html#introduction-of-transient-perturbations-of-the-microbiota)
#' @param env_gen vector of booleans.
#' @param seed seed value for samplings in the function.
#' @param verbose bool, DEFAULT = T
#'
#' @section Required parameters:
#' - `h2`
#' - `b2`
#' - `founder_object`
#' - `n_ind`
#' - `n_clust`
#'
#' @section Generation parameters:
#' - `n_gen`
#'
#' @section Genotype-related parameters:
#' - `qtn_y`
#'
#' @section Microbiome-related parameters:
#' - `correlation`
#' - `otu_g`
#' - `lambda`
#' - `effect.size`
#' - `mix.params`
#' - `mix.params.M`
#' - `noise.microbiome`
#' - `dir`
#' - `ao`
#'
#' @section Selection-related parameters:
#' - `selection` 
#' - `size_selection_F`, `size_selection_M` 
#' - `selection_type` 
#'
#' @section Environmental effects:
#' - `thetaX`
#' - `env_gen`
#'
#' @section Misc:
#' - `seed`
#' - `verbose` 
#' 
#' @return
#' A big list object with metada info such as beta matrix details and each generation at level 1. For each generation, the genotypes, the microbiomes, the phenotypes, the pedigree and the individuals selected can be reachable.
#' 
#' @seealso [compute_beta_matrix_cluster()], [compute_mean_microbiome()], [compute_current_microbiome()], [compute_phenotypes()]
#' @rdname holo_simu
#' @export
holo_simu <- function(### Required parameters ###
                      h2,
                      b2,
                      founder_object,
                      n_ind = NULL,
                      n_clust = NULL,
                      ###
                      
                      ### Generations parameters ###
                      n_gen = 5,
                      ###
                      
                      ### Genotypes parameters ###
                      qtn_y = NULL,        
                      ###
                      
                      ### Microbiome-related parameters ###
                      correlation = 0.5,
                      otu_g = 0.05,
                      lambda = 0.5,
                      effect.size = 0.1,
                      mix.params = c(0.75,0.25),
                      mix.params.M = c(0.75,0.25),
                      noise.microbiome = 0.1,
                      dir = T,
                      ao = 25,
                      ###
                      
                      ### Selection-related parameters ###
                      size_rmultinom = 10000,
                      selection = F,       
                      size_selection_F = NULL,
                      size_selection_M = NULL,
                      selection_type = "GB",
                      w.param = c(0.5,0.5),
                      ###
                      
                      ### Environmental-effects-related parameters ###
                      thetaX = NULL,
                      env_gen = NULL,
                      ###
                      
                      ### Additional parameters ###
                      seed=1234,
                      verbose = T
                      ###
                      ){
  set.seed(seed)
  
  population <- attr(founder_object,"population")
  #obtain genotypes for all generation using MoBPS breeding.diploid
  if(is.null(n_ind)){
    n_ind <- ncol(founder_object)
  }
  
  ######
  #call to compute beta matrix function, common for all generations
  ######
  microbiome_filtered <- founder_object |> t()
  n_g <- nrow(get.geno(population, gen=1))
  
  #####################
  ### beta matrix generation
  #####################
    n_clust_g <- n_clust[n_clust != 0] %>% unique() %>% length()
    n_qtl_o <- ((n_g * 0.2)/n_clust_g)  %>% round()
    beta <- compute_beta_matrix_cluster(n_b = nrow(microbiome_filtered), 
                                        n_g = n_g, 
                                        n_clust = n_clust, 
                                        n_qtl_o = n_qtl_o, 
                                        n_otus = sum(n_clust != 0), 
                                        correlation = correlation, 
                                        effect_size = effect.size)
  beta_info <- attr(beta,"sim_params")
  otu_list <- list_c(beta_info$id_otu)
  
  ######
  #loop on generation to obtain microbiome
  ######
  ## ML estimate of founder pop compositions
  microbiome_gen <- apply(microbiome_filtered, 2, \(x) x/sum(x))
  ## shrinkage estimator: weighted average of ML composition and pop-level mean composition followed by clr transform
  microbiome_gen <- (mix.params[1] * microbiome_gen + mix.params[2] * matrix(rowMeans(microbiome_gen),nrow=nrow(microbiome_gen),ncol=ncol(microbiome_gen),byrow=F)) |> t() |> clr() |> t()
  # microbiome_gen <- microbiome_gen |> replace_zero() |> t() |> compositions::clr() |> t()
  #abundances
  taxa_scale <- microbiome_gen |> apply(1, sd)
  colnames(microbiome_gen) <- get.geno(population, gen = 1) %>% colnames()
  
  if(is.null(qtn_y)){
    Nqtl_y = 100
  }else{
    Nqtl_y = qtn_y
  }
  
  #####################
  ### founder phenotypes and parameters calibration
  #####################
  params_phenotypes <- calibrate_params_phenotypes(X0 = get.geno(population,gen = 1),
                                                   B0 = microbiome_gen, #CLR abundances ,
                                                   h2 = h2,
                                                   b2 = b2,
                                                   otu_list = otu_list,
                                                   Nqtl_y = Nqtl_y,
                                                   Notu_y = length(otu_list))
  
  phenotypes_founder <- compute_phenotypes(X = get.geno(population,gen = 1), 
                                           B = microbiome_gen, #CLR abundances 
                                           Nqtl_y = Nqtl_y, 
                                           Notu_y = length(otu_list), 
                                           otu_list = otu_list,
                                           qtl_list = params_phenotypes$qtl_list,
                                           beta_qtl = params_phenotypes$alpha,
                                           beta_otu = params_phenotypes$omega,
                                           se = params_phenotypes$se)
  
  
  #####################
  ### first elements output
  #####################
  metadata <- list(Beta_matrix = beta, 
                   QTN_y = params_phenotypes$qtl_list, 
                   G_coeff = params_phenotypes$alpha, 
                   B_coeff = params_phenotypes$omega)
  G0 <- list(microbiome = microbiome_gen |>  t() |> clrInv() |> t(), 
             genotypes = get.geno(population,gen = 1), 
             phenotypes = phenotypes_founder)
  list_output <- list(metadata = metadata, G0 = G0)
  
  
  #####################
  #Generation for loop
  ####################
  for(i in 1:n_gen){
    start_g <- proc.time()
    if(verbose){
      print(glue("Generation : {i}"))
    }
    #Warning : outside MoBPS functions, index of generation is i+1
    ######
    # Step 1 : get_current_genotype
    ######
    if(i==1){
      #renames microbiome matrix with individuals names
      population <- breeding.diploid(population,
                                     breeding.size = c(n_ind/2,n_ind/2),
                                     verbose = F)
    }else{
      population <- breeding.diploid(population,
                                     breeding.size = c(n_ind/2,n_ind/2), 
                                     selection.m.database = cbind(i,1,as.numeric(ID_selected$M_id)), 
                                     selection.f.database = cbind(i,2,as.numeric(ID_selected$F_id)),
                                     verbose = F)
    }
    
    ######
    # Step 2 : get_current_microbiome
    ######
    #Extract microbiomes of the mothers
    microbiome_gen <- microbiome_gen |>  t() |> clrInv() |> t()
    current_mother_microbiomes <- sapply(get.pedigree(population, gen=i+1)[,"mother"],function(x){
      microbiome_gen[,x]
    })
    
    mean_microbiome <- compute_mean_microbiome(microbiome_gen, 
                                               dir = dir,
                                               n_ind = n_ind,
                                               ao = ao,
                                               mix.params = mix.params.M)
    
    if(!is.null(env_gen)){
      if(env_gen[i]){
        microbiome_gen <- compute_current_microbiome(beta = beta,
                                                     current_genotypes = get.geno(population,gen = i+1),
                                                     mother_microbiomes = current_mother_microbiomes,
                                                     mean_microbiome = mean_microbiome,
                                                     noise = noise.microbiome, taxa_scale = taxa_scale, 
                                                     lambda = lambda,
                                                     dir = dir,
                                                     thetaX = thetaX) #not mandatory if we check dimension of mean_microbiome
      }else{
        microbiome_gen <- compute_current_microbiome(beta = beta,
                                                     current_genotypes = get.geno(population,gen = i+1),
                                                     mother_microbiomes = current_mother_microbiomes,
                                                     mean_microbiome = mean_microbiome,
                                                     noise = noise.microbiome, taxa_scale = taxa_scale, 
                                                     lambda = lambda,
                                                     dir = dir,
                                                     thetaX = NULL)
      }
    }else{
      microbiome_gen <- compute_current_microbiome(beta = beta,
                                                   current_genotypes = get.geno(population,gen = i+1),
                                                   mother_microbiomes = current_mother_microbiomes,
                                                   mean_microbiome = mean_microbiome,
                                                   noise = noise.microbiome, taxa_scale = taxa_scale, 
                                                   lambda = lambda,
                                                   dir = dir,
                                                   thetaX = NULL)
    }
    ######
    # Step 3 : get_current_phenotype
    ######
    phenotypes <- compute_phenotypes(X = get.geno(population,gen = i+1), 
                                     B = microbiome_gen, #CLR abundances 
                                     Nqtl_y = Nqtl_y, 
                                     Notu_y=length(otu_list), 
                                     otu_list = otu_list,
                                     qtl_list = params_phenotypes$qtl_list,
                                     beta_qtl = params_phenotypes$alpha,
                                     beta_otu = params_phenotypes$omega,
                                     se = params_phenotypes$se)
    
    
    ######
    # Step 4 : compute TBV to select individuals
    ######
    
    ID_selected <- select_individual(phenotypes = phenotypes,
                                     microbiomes = microbiome_gen |>  t() |> clrInv() |> t(),
                                     genotypes = get.geno(population,gen = 1+i),
                                     beta = beta,
                                     beta_otu = params_phenotypes$omega,
                                     selection = selection,
                                     size_selection_F = size_selection_F,
                                     size_selection_M = size_selection_M,
                                     selection_type = selection_type,
                                     size_rmultinom = size_rmultinom,
                                     w.param = w.param) 

    ###
    #update output
    ###
    list_output[[glue("G{i}")]] <- list(microbiome = microbiome_gen |>  t() |> clrInv() |> t(),
                                        genotypes = get.geno(population,gen = 1+i),
                                        phenotypes = phenotypes,
                                        pedigree = get.pedigree(population,gen = i+1),
                                        mean_microbiome = mean_microbiome,
                                        noise_microbiome = attr(microbiome_gen,"noise_microbiome"),
                                        ID_selected = c(glue("F_{ID_selected$F_id}"),glue("M_{ID_selected$M_id}")),
                                        omega_beta_g = as.vector(params_phenotypes$omega %*% (beta[rowSums(beta) != 0, ] %*% get.geno(population,gen = 1+i))))
    if(verbose){
      end_g <- proc.time() - start_g
      print(glue("Executed in {round(end_g[1] |> as.numeric(),3)} seconds"))
    }
  }
  return(list_output)
}

```

```{r examples-holo_simu, warning=FALSE, message=FALSE}
\dontrun{
  data("Deru")
  ToyData <- Deru
  taxa_assign_g <- assign_taxa(founder_object = ToyData)
  generations_simu <- holo_simu(h2 = 0.25,
                                 b2 = 0.25,
                                 founder_object = ToyData,
                                 n_clust = taxa_assign_g,
                                 n_ind = 500,
                                 verbose = FALSE,
                                 noise.microbiome = 0.5,
                                 effect.size = 0.3,
                                 lambda = 0.5,
                                 dir = TRUE,
                                 selection = FALSE,
                                 seed = 1234)
}  
```


```{r function-richness_from_abundances_gen}

#' Estimate diversity metrics from relative abundances
#' 
#' This function estimate diversity metrics (Observed, Shannon, Inverse Simpson) from the matrix of relative abundances (see [get_microbiomes()]).
#' It uses multinomial sampling to simulate read counts from abundances, and computes diversity metrics across `n_loop` in order to obtain robust estimation. This function is particularly useful when selection is based on diversity.
#' 
#' @importFrom phyloseq phyloseq estimate_richness otu_table
#' 
#' @param microbiome_matrix A matrix of relative abundances (individuals in rows and OTUs in columns, see [get_microbiomes()] output).
#' @param size_rmultinom Integer; specifying the total number of object for the multinomial sampling(default: 10000, according to DeruPop.rds dataset).
#' @param n_loop Integer; number of multinomial resampling iterations to perform (default: 10).
#' @param plot Logical; not currently implemented
#' 
#' @return A `data.frame`of average diversity metrics (Observed, Shannon, Inverse Simpson) for each sample.
#'
#' @seealso [get_microbiomes()], [phyloseq::estimate_richness()]
#' @export
richness_from_abundances_gen <- function(microbiome_matrix, size_rmultinom = 10000, n_loop = 10, plot=T){
  microbiome_matrix[microbiome_matrix<0] <- 0
  for(i in 1:n_loop){
    microbiome_matrix <- apply(microbiome_matrix, 2, function(x){
      rmultinom(1,size_rmultinom,as.vector(x))
    })
    tmp_physeq <- phyloseq(otu_table(microbiome_matrix,taxa_are_rows = T))
    if(i==1){
      richness <- estimate_richness(tmp_physeq,measures = c("Observed","Shannon","InvSimpson"))
    }else{
      richness <- richness + estimate_richness(tmp_physeq,measures = c("Observed","Shannon","InvSimpson"))
    }
  }
  return(richness/n_loop)
}

```

```{r examples-richness_from_abundances_gen, message=FALSE, warning=FALSE}
\dontrun{
library(magrittr)
library(purrr)
data("Deru")
ToyData <- Deru
taxa_assign_g <- assign_taxa(founder_object = ToyData)
generations_simu <- holo_simu(h2 = 0.25, b2 = 0.25, founder_object = ToyData,
                               n_clust = taxa_assign_g, n_ind = 500,
                               verbose = FALSE, seed = 1234)
                               
# Extract microbiomes matrix for each generations
microbiomes <- generations_simu[-1] %>% map(get_microbiomes)
 
# Estimate diversity metrics
richness_from_abundances <- microbiomes %>% map(richness_from_abundances_gen, size_rmultinom = 10000) 
## size_rmultinom = 10000 according to DeruPops dataset
}
```

```{r tests-holo_simu}
```

# Get functions 

```{r function-get_microbiomes}
#' Useful function to extract microbiomes from RITHMS output
#' 
#' The gets functions use the output of [holo_simu()] to extract the information of interest from a given generation.
#' `get_microbiomes` extract the microbiome abundance matrix from a generation object, with or without CLR transformation or transposition.
#' 
#' @importFrom compositions clr
#' @importFrom purrr pluck
#' @importFrom tibble as_tibble
#' @importFrom magrittr %>%
#' 
#' @param data List corresponding to one generation, as returned by `holo_simu()`. Containing simulation output.
#' @param transpose Logical; if `TRUE`, transpose the microbiome matrix (OTUs in rows, individuals in columns).
#' @param CLR Logical; if `TRUE`, applies a CLR transformation to the abundance data. This transformation requires `transpose = TRUE`.
#' 
#' @return A `data.frame`containing the microbiome abundances of individuals. Default, individuals are in rows and OTUs in columns. Change `transpose`parameter if needed.
#' 
#' @examples
#' \dontrun{
#' library(magrittr)
#' library(purrr)
#' data("Deru")
#' ToyData <- Deru
#' taxa_assign_g <- assign_taxa(founder_object = ToyData)
#' generations_simu <- holo_simu(h2 = 0.25, b2 = 0.25, founder_object = ToyData,
#'                               n_clust = taxa_assign_g, n_ind = 500,
#'                               verbose = FALSE, seed = 1234)
#' 
#' # Extract microbiome matrix for G1 generation
#' G1_microbiome <- get_microbiomes(generations_simu$G1)
#' 
#' # Extract with transposition
#' G1_t_microbiome <- get_microbiomes(generations_simu$G1, transpose = TRUE)
#' 
#' # Extract with CLR transformation
#' G1_CLR_microbiome <- get_microbiomes(generations_simu$G1, transpose = TRUE, CLR = TRUE)
#' 
#' # Extract all microbiome matrices of all generations
#' # substract metadata
#' microbiomes <- generations_simu[-1] %>% map(get_microbiomes)
#' }
#' 
#' @seealso [get_mean_phenotypes()], [get_phenotypes_value()], [get_om_beta_g()], [get_selected_ind()], [get_phenotypes()]
#' @rdname get_microbiomes
#' @export
get_microbiomes <- function(data, transpose = F, CLR = F) {
  if(transpose){
    if(CLR){
      return(data |> pluck("microbiome") |> t() |> replace_zero() |> clr() |> as.data.frame())
    }else{
      return(data |> pluck("microbiome") |> t() |> as.data.frame())
    }
  }
  data |> pluck("microbiome") |> as.data.frame()
}
```

```{r function-get_mean_phenotypes}
#' Useful function to extract mean phenotype values from RITHMS output
#'
#' The gets functions use the output of [holo_simu()] to extract the information of interest from a given generation.
#' `get_mean_phenotypes`extract average phenotype from a generation object.
#' 
#' @importFrom purrr pluck
#' @importFrom magrittr %>%
#' 
#' @param data List corresponding to one generation, as returned by [holo_simu()]. Containing simulation output.
#' @return The mean phenotype value for a given generation.
#' @examples
#' \dontrun{
#' library(purrr)
#' library(magrittr)
#' data("Deru")
#' ToyData <- Deru
#' taxa_assign_g <- assign_taxa(founder_object = ToyData)
#' generations_simu <- holo_simu(h2 = 0.25, b2 = 0.25, founder_object = ToyData,
#'                               n_clust = taxa_assign_g, n_ind = 500,
#'                               verbose = FALSE, seed = 1234)
#'                               
#' # Extract mean phenotype value for G1 generation
#' G1_mean_phenotype <- get_mean_phenotypes(generations_simu$G1)
#' 
#' # Extract mean phenotype values of all generations
#' ## Don't forget to substract the metadata
#' mean_phenotypes <- generations_simu[-1] %>% map(get_mean_phenotypes)
#' }
#' 
#' @seealso [get_microbiomes()], [get_phenotypes_value()], [get_om_beta_g()], [get_selected_ind()], [get_phenotypes()]
#' @rdname get_mean_phenotypes
#' @export
get_mean_phenotypes <- function(data) {
  data |> pluck("phenotypes","y") |> mean()
}

```

```{r function-get_phenotypes_values}
#' Useful function to extract phenotype values from RITHMS output ("gq" by default)
#' 
#' The gets functions use the output of [holo_simu()] to extract the information of interest from a given generation.
#' `get_phenotypes_values` extract the set of phenotype values from a generation object.
#' 
#' @importFrom purrr pluck
#' @importFrom magrittr %>%
#' 
#' @param data List corresponding to one generation, as returned by [holo_simu()]. Containing simulation output.
#' @param value A String caracter that precise the object to extract from the generation object. Must be "gq" to extract phenotype values.
#' @return A `data.frame` of phenotype values for each individuals of a given generation.
#' 
#' @examples
#' \dontrun{
#' library(magrittr)
#' library(purrr)
#' data("Deru")
#' ToyData <- Deru
#' taxa_assign_g <- assign_taxa(founder_object = ToyData)
#' generations_simu <- holo_simu(h2 = 0.25, b2 = 0.25, founder_object = ToyData,
#'                               n_clust = taxa_assign_g, n_ind = 500,
#'                               verbose = FALSE, seed = 1234)
#'                               
#'  #Extract phenotype values for each individuals of G1 generation
#'  G1_phenotypes_values <- get_phenotypes_value(generations_simu$G1)
#'  
#'  #Extract phenotype values for each individuals of all generations
#'  ## Don't forget to substract the metadata
#'  phenotypes_values <- generations_simu[-1] %>% map(get_phenotypes_value)
#'  }
#'  
#' @seealso [get_mean_phenotypes()], [get_microbiomes()], [get_om_beta_g()], [get_selected_ind()], [get_phenotypes()]
#' @rdname get_phenotypes_value
#' @export
get_phenotypes_value <- function(data, value = "gq") {
  data |> pluck("phenotypes",value)
}
```

```{r function-get_om_beta_g}
#' Useful function to extract omega beta G values from RITHMS output
#' 
#' The gets functions use the output of [holo_simu()] to extract the information of interest from a given generation.
#' `get_om_beta_g`extract omega beta G values from a generation object.
#' 
#' @importFrom purrr pluck
#' @importFrom magrittr %>%
#' 
#' @param data List corresponding to one generation, as returned by [holo_simu()]. Containing simulation output.
#' @return A `data.frame` of omega beta G values for each individuals of a given generation.
#' 
#' @examples
#' \dontrun{
#' library(magrittr)
#' library(purrr)
#' data("Deru")
#' ToyData <- Deru
#' taxa_assign_g <- assign_taxa(founder_object = ToyData)
#' generations_simu <- holo_simu(h2 = 0.25, b2 = 0.25, founder_object = ToyData,
#'                               n_clust = taxa_assign_g, n_ind = 500,
#'                               verbose = FALSE, seed = 1234)
#'                               
#' #Extract omega beta G values for each individuals of G1 generation
#' G1_om_beta_g <- get_om_beta_g(generations_simu$G1)
#'  
#' #Extract omega beta G values for each individuals of all generations
#' ## Don't forget to substract the metadata
#' om_beta_g <- generations_simu[-1] %>% map(get_om_beta_g)
#'}
#'  
#' @seealso [get_mean_phenotypes()], [get_phenotypes_value()], [get_microbiomes()], [get_selected_ind()], [get_phenotypes()]
#' @rdname get_om_beta_g
#' @export
get_om_beta_g <- function(data) {
  data |> pluck("omega_beta_g")
}
```

```{r function-get_selected_ind}
#' Useful function to extract ID of selected individuals from RITHMS output
#'
#'The gets functions use the output of [holo_simu()] to extract the information of interest from a given generation.
#' `get_selected_ind`extract selectd individuals IDs from a generation object.
#' 
#' @importFrom purrr pluck
#' @importFrom magrittr %>%
#' 
#' @param data List corresponding to one generation, as returned by [holo_simu()]. Containing simulation output.
#' 
#' @return A`list` of the selected individuals of a given generation.
#' @examples
#' \dontrun{
#' library(magrittr)
#' library(purrr)
#' data("Deru")
#' ToyData <- Deru
#' taxa_assign_g <- assign_taxa(founder_object = ToyData)
#' generations_simu <- holo_simu(h2 = 0.25, b2 = 0.25, founder_object = ToyData,
#'                               n_clust = taxa_assign_g, n_ind = 500,
#'                               verbose = FALSE, seed = 1234)
#'                               
#' #Extract selected individuals IDs for the G1 generation
#' G1_selected_ind <- get_selected_ind(generations_simu$G1)
#'  
#' #Extract selected individuals IDs for all generations
#' ## Don't forget to substract the metadata
#' selected_ind <- generations_simu[-1] %>% map(get_selected_ind)
#' }
#' 
#' @seealso [get_mean_phenotypes()], [get_phenotypes_value()], [get_om_beta_g()], [get_microbiomes()], [get_phenotypes()]
#' @rdname get_selected_ind
#' @export
get_selected_ind <- function(data) {
  data |> pluck("ID_selected")
}
```

```{r function-get_phenotypes}
#' Useful function to extract all phenotype values as data frame from RITHMS output
#' 
#' The gets functions use the output of [holo_simu()] to extract the information of interest from a given generation.
#' `get_phenotypes`extract phenotype for each individuals as the combined effects of microbiota and direct genetic effects, from a generation object.
#' 
#' @importFrom purrr pluck
#' @importFrom magrittr %>%
#' 
#' @param data List corresponding to one generation, as returned by [holo_simu()]. Containing simulation output.
#' @return A `data.frame` of phenotype for each individuals of a given generation. Phenotype values are given as the result of the combined effects of the microbiota and direct genetic effects.
#' 
#' @examples
#' \dontrun{
#' library(magrittr)
#' library(purrr)
#' data("Deru")
#' ToyData <- Deru
#' taxa_assign_g <- assign_taxa(founder_object = ToyData)
#' generations_simu <- holo_simu(h2 = 0.25, b2 = 0.25, founder_object = ToyData,
#'                               n_clust = taxa_assign_g, n_ind = 500,
#'                               verbose = FALSE, seed = 1234)
#'                               
#' #Extract phenotypes of the G1 generation
#' G1_phenotypes <- get_phenotypes(generations_simu$G1)
#'  
#' #Extract phenotypes for all generations
#' ## Don't forget to substract the metadata
#' phenotypes <- generations_simu[-1] %>% map(get_phenotypes)
#' }
#' 
#' @seealso [get_mean_phenotypes()], [get_phenotypes_value()], [get_om_beta_g()], [get_selected_ind()], [get_microbiomes()]
#' @rdname get_phenotypes
#' @export
get_phenotypes <- function(data) {
  data |> pluck("phenotypes") |> as.data.frame() |> as_tibble(rownames = "ID") 
}
```

```{r function-get_mean_diversity}
#' Useful function to extract Shannon diversity from RITHMS output
#' 
#' The gets functions use the output of [holo_simu()] to extract the information of interest from a given generation.
#' `get_mean_diversity`extract the average Shannon diversity from a generation object.
#' 
#' @note This function requires a previous call to [richness_from_abundances_gen()] to compute different types of diversity within the generation.
#' 
#' @importFrom purrr pluck
#' @importFrom magrittr %>%
#' 
#' @param data List corresponding to one generation, as returned by [holo_simu()]. Containing simulation output.
#' @return The average Shannon diversity within a given generation.
#' 
#' @examples
#' \dontrun{
#' library(magrittr)
#' library(purrr)
#' data("Deru")
#' ToyData <- Deru
#' taxa_assign_g <- assign_taxa(founder_object = ToyData)
#' generations_simu <- holo_simu(h2 = 0.25, b2 = 0.25, founder_object = ToyData,
#'                               n_clust = taxa_assign_g, n_ind = 500,
#'                               verbose = FALSE, seed = 1234)
#'                               
#' # Extract Shannon diversity for each generations
#' ## First step, compute richness from abundances
#' richness_from_abundances <- generations_simu[-1] %>% map(get_microbiomes) %>% map(richness_from_abundances_gen, size_rmultinom = 10000)
#' ## size_rmultinom = 10000 according to DeruPops dataset
#' 
#' mean_shannon_diversity <- richness_from_abundances %>% map(get_mean_diversity)
#' }
#' @seealso [get_microbiomes()], [richness_from_abundances_gen()]
#' @rdname get_mean_diversity
#' @export
get_mean_diversity <- function(data) {
  mean(data$Shannon)
}
```

```{r examples-get, message=FALSE, warning=FALSE}
\dontrun{
library(magrittr)
library(purrr)

data("Deru")
ToyData <- Deru
taxa_assign_g <- assign_taxa(founder_object = ToyData)
generations_simu <- holo_simu(h2 = 0.25,
                              b2 = 0.25,
                              founder_object = ToyData,
                              n_clust = taxa_assign_g,
                              n_ind = 500,
                              verbose = FALSE,
                              noise.microbiome = 0.5,
                              effect.size = 0.3,
                              lambda = 0.5,
                              dir = TRUE,
                              selection = FALSE,
                              seed = 1234)

# To extract CLR abundances of the G1 generation microbiome
G1_microbiome <- get_microbiomes(generations_simu$G1, CLR = TRUE)

# To extract all the relative abundances of microbiomes from all generations
# substract metadata
microbiomes <- generations_simu[-1] %>% map(get_microbiomes)

# To extract mean phenotypes of all generations
mean_phenotypes <- generations_simu[-1] %>% map(get_mean_phenotypes)

# To extract phenotypic values for each individual of generation G1
G1_phenotypes_values <- get_phenotypes_value(generations_simu$G1)

# To extract the phenotype of each generation as the combined effects of microbiota and direct genetic effects
phenotypes <- generations_simu[-1] %>% map(get_phenotypes)

# To extract omega beta G values for each individual of generation G1
G1_om_beta_g <- get_om_beta_g(generations_simu$G1)

# To extract ID of selected individuals to each generation
selected_inds <- generations_simu[-1] %>% map(get_selected_ind) 

# To extract Shannon diversity
# First step, compute richness from abundances
richness_from_abundances <- generations_simu[-1] %>% map(get_microbiomes) %>% map(richness_from_abundances_gen)
shannon_diversity <- richness_from_abundances %>% map(get_mean_diversity)
}
```


# Additional functions

```{r function-transform_geno_into_vcf}
#' Convert a 0/1/2 genotype matrix into a VCF-like format
#'
#' This function converts a genotype matrix encoded as 0,1,2 into a VCF-like format. It can either return the VCF content as a `data.frame`, write it to a .vcf file or do both.
#'
#' @param geno_matrix A matrix of genotypes with values 0, 1, 2. SNPs are in rows and individuals in columns.
#' @param output_type A character, that specifies the output type. Choose between `"file"` (write `.vcf`),
#'                    `"dataframe"` (return `data.frame`), or `"both"` (do both).
#' @param output_path A character string that specifies the output path. Requiered if `output_type` is "file" or "both".
#' 
#' @return A `data.frame` if `output_type = "dataframe" or "both"`, or just write the `.vcf` file if `output_type = "file" or "both"`.
#' 
#' @rdname transform_geno_into_vcf
#' @export

transform_geno_into_vcf <- function(geno_matrix, output_type = c("file", "dataframe", "both"), output_path = NULL){
  
    n_ind = ncol(geno_matrix)
    n_snp = nrow(geno_matrix)
    
    convert_to_haplo <- function(x) {
    if(is.na(x)) return(".")
    if (x == 0) return("0/0")
    if (x == 1) return("0/1")
    if (x == 2) return("1/1")
    }
  
    geno_matrix_haplo <- apply(geno_matrix, c(1,2), convert_to_haplo)
  
    vcf_header <- c(
      "##fileformat=VCFv4.2",
      paste0("##FORMAT=<ID=GT,Number=1,Type=String,Description=\"Genotype\">"),
      paste("#CHROM", "POS", "ID", "REF", "ALT", "QUAL", "FILTER", "INFO", "FORMAT", paste0("Indiv_", 1:n_ind), sep="\t")
    )
  
    vcf_snps <- data.frame(
      CHROM = "1", 
      POS = 1:n_snp, 
      ID = paste0("rs", 1:n_snp), 
      REF = "A", ALT = "T", 
      QUAL = ".", FILTER = ".", INFO = ".", FORMAT = "GT",
      geno_matrix_haplo
    )
    
    if(output_type %in% c("file", "both")){
      write.table(vcf_snps, file = output_path, sep = "\t", quote = FALSE, row.names = TRUE, col.names = TRUE)
      
    } else if(output_type %in% c("dataframe", "both")){
      return(vcf_snps)
    } else{
      print("The output type must be one of 'file' or 'dataframe'.")
    }
}
```


```{r examples-transform_geno_into_vcf}
n_ind <- 50
n_snp <- 50

# Create a little genotype matrix
set.seed(123)
geno_matrix <- matrix(sample(0:2, size = n_ind*n_snp, replace = TRUE),
                      nrow = n_snp, ncol = n_ind)

# Transform genotype matrix into VCF
vcf <- transform_geno_into_vcf(geno_matrix, output_type = "dataframe")
head(vcf[1:3,1:7])
```

# Deru

```{r function-Deru}
#' Deru Dataset
#' 
#' A subset of data from [Dru et al. 2020](https://pmc.ncbi.nlm.nih.gov/articles/PMC7538339/) containing hologenomic data from 750 pigs fed a conventional diet. Genotypes are accessible thanks to the "population" attribute.
#' 
#' @format A matrix with 780 rows (individuals) and 1845 taxa, where each element represents the abundance of a specific taxon in a specific individual. Additionnally, there is an attribute "population" wich provides the genotypes of each individual, encoded as 0, 1 ,2.
#' 
#' @source [Dru et al.](https://pmc.ncbi.nlm.nih.gov/articles/PMC9194801/) for microbiota data and [Dru et al. 2020](https://pmc.ncbi.nlm.nih.gov/articles/PMC7538339/) for genotypes data.
#' 
#' @examples
#' # Access the dataset
#' data("Deru")
#' 
#' # View the first few rows of the taxa matrix
#' head(Deru[1:5,1:5])
#' 
#' # Access the population attribute to view genotypes
#' population <- attr(Deru, "population")
"Deru"
```


<!--
# There can be development actions

Create a chunk with 'development' actions

- The chunk needs to be named `development` or `dev`
- It contains functions that are used for package development only
- Note that you may want to store most of these functions in the 0-dev_history.Rmd file

These are only included in the present flat template file, their content will not be part of the package anywhere else.
-->

```{r development-inflate, eval=FALSE}
# Keep eval=FALSE to avoid infinite loop in case you hit the knit button
# Execute in the console directly
fusen::inflate(flat_file = "dev/flat_first.Rmd", vignette_name = "Get started")
```
