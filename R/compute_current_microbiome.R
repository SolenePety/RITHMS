# WARNING - Generated by {fusen} from dev/flat_first.Rmd: do not edit by hand # nolint: line_length_linter.

#' Compute microbiomes for all individuals of current generation gathering all relevant object already computed.
#' 
#' @importFrom compositions clr
#' @importFrom magrittr %>%
#' 
#' @param beta A `matrix` of taxa (rows) by SNPs (columns) representing the multiplicative effect of SNPs on taxa abundances. Typically the output of [compute_beta_matrix_cluster()]
#' @param current_genotypes A `matrix` of genotypes for the individuals of the current generation.
#' @param mother_microbiomes A `matrix` containing the CLR-transformed abundances from the microbiome of the current mothers.
#' @param mean_microbiome A `numeric` vector representing the average abundances of the microbiome within the population.
#' @param noise A `numeric` scalar indicating the standard deviation of the Gaussian noise to add during beta g construction [compute_beta_g()](multiplicative genetic effect on taxa abundances).
#' @param taxa_scale A `numeric` scalar to scale the noise added to each OTUs abundance, see [compute_beta_g()].
#' @param lambda A `numeric` between 0 and 1 controlling the relative contribution of the mother microbiome compared to the average microbiome.
#' @param dir A `logical`;
#' @param thetaX A `matrix` representing the environmental effect (optional).
#' 
#' @return A `matrix` of CLR-transformed abundances of the microbiome for each individual of the current generation.
#' 
#' @seealso [compute_mean_microbiome()]
#' @rdname compute_current_microbiome 

compute_current_microbiome <- function(beta,
                                       current_genotypes,
                                       mother_microbiomes,
                                       mean_microbiome,
                                       noise=0.1,
                                       taxa_scale, 
                                       lambda=0.5,
                                       dir = F,
                                       thetaX){
  
  beta_g_eps <- compute_beta_g(beta = beta, genotypes = current_genotypes, noise = noise, taxa_scale = taxa_scale)
  if(dir){
    internal_compute <- lambda*(mother_microbiomes) + (1-lambda)*mean_microbiome
  }else{
    internal_compute <- lambda*(mother_microbiomes) + (1-lambda)*matrix(mean_microbiome,nrow=nrow(beta_g_eps),ncol=ncol(beta_g_eps),byrow=F)
  }
  #TODO : check dimensions of thetaX
  if(!is.null(thetaX)){
    microbiome <- t(clr(t(internal_compute)%>% replace_zero())) + beta_g_eps + thetaX
  }else{
    microbiome <- t(clr(t(internal_compute)%>% replace_zero())) + beta_g_eps
  }
  colnames(microbiome) <- colnames(beta_g_eps)
  
  attr(microbiome,"noise_microbiome") <- list('attr'=attr(beta_g_eps,"noise"), 
                                              'clr_mic' = t(clr(t(internal_compute)%>% replace_zero())),
                                              'env_eff' = thetaX)
  #return CLR(microbiome)
  return(microbiome)
}

#' Replace zero in the matrix by 1e-15 to avoid infinite values when CLR transformation is computed
#' 
#' @importFrom compositions oneOrDataset is.NMV
#' 
#' @param x A matrix
#' @export
replace_zero <- function(x){
  W <- oneOrDataset(x)
  nmv <- is.NMV(W)
  ifelse(nmv, W, 1e-15)
}
