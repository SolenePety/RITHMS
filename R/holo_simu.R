# WARNING - Generated by {fusen} from dev/flat_first.Rmd: do not edit by hand # nolint: line_length_linter.

#' Main function to generate transgenerational hologenomic data 
#'
#' @importFrom MoBPS get.geno breeding.diploid get.pedigree
#' @importFrom compositions clr clrInv
#' @importFrom glue glue
#' @importFrom phyloseq phyloseq estimate_richness
#'
#' @param h2 direct heritability value, between 0 and 1 
#' @param b2 microbiability value, between 0 and 1
#' @param founder_object output of generate_founder() function
#' @param otu_g percentage of taxa under genetic control, between 0 and 1, DEFAULT = 0.05
#' @param qtn_y number of causal SNPs for the phenotypes
#' @param n_ind number of individual per generation
#' @param n_gen number of generation, DEFAULT = 5
#' @param n_clust vector with taxa assignment, typical output of assign_taxa
#' @param selection bool, if selection process needed, DEFAULT = FALSE
#' @param size_selection_F percentage of female to select
#' @param size_selection_M percentage of male to select
#' @param selection_type mode of selection to be used, value in ("GB", "B", "G", "diversity", "div.GB"), DEFAULT = "GB"
#' @param seed seed value for samplings in the function
#' @param verbose bool, DEFAULT = T
#' @param lambda proportion of microbiome of offspring coming from vertical transmission, DEFAULT = 0.5
#' @param correlation Correlation between taxa within the same cluster, value between 0 and 1, DEFAULT = 0.5
#' @param mix.params Vector of two values giving the weights for the regularisation of the base population microbiome. mix.params[1] = weight for raw microbiome and mix.params[2] = weight for mean microbiome. DEFAULT = c(0.75,0.25)
#' @param mix.params.M
#' @param effect.size
#' @param noise.microbiome sd of microbiome noise, DEFAULT = 0.1
#' @param dir bool
#' @param ao for dirichlet sampling parameter
#' @param thetaX if environmental effect
#' @param env_gen vector of bool
#' @param w.param in case div.GB selection mode is chosen
#' 
#'
#' @return
#' A big list object with metada info such as beta matrix details and each generation at level 1. For each generation, the genotypes, the microbiomes, the phenotypes, the pedigree and the individuals selected can be reachable.
#' @rdname holo_simu
#' @export
holo_simu <- function(h2,
                      b2,
                      founder_object,
                      otu_g = 0.05,       
                      qtn_y = NULL,        
                      n_ind = NULL,       
                      n_gen = 5,         
                      n_clust = NULL,    
                      selection = F,       
                      size_selection_F = NULL,
                      size_selection_M = NULL,
                      selection_type = "GB",
                      seed=1234,
                      verbose = T,
                      lambda = 0.5,
                      correlation = 0.5,
                      mix.params = c(0.75,0.25),
                      mix.params.M = c(0.75,0.25),
                      effect.size = 0.1,
                      noise.microbiome = 0.1,
                      dir = F,
                      ao = 25,
                      thetaX = NULL,
                      env_gen = NULL,
                      w.param = c(0.5,0.5)){
  set.seed(seed)
  
  population <- attr(founder_object,"population")
  #obtain genotypes for all generation using MoBPS breeding.diploid
  if(is.null(n_ind)){
    n_ind <- ncol(founder_object)
  }
  
  ######
  #call to compute beta matrix function, common for all generations
  ######
  microbiome_filtered <- founder_object |> t()
  n_g <- nrow(get.geno(population, gen=1))
  
  #####################
  ### beta matrix generation
  #####################
    n_clust_g <- n_clust[n_clust != 0] %>% unique() %>% length()
    n_qtl_o <- ((n_g * 0.2)/n_clust_g)  %>% round()
    beta <- compute_beta_matrix_cluster(n_b = nrow(microbiome_filtered), 
                                        n_g = n_g, 
                                        n_clust = n_clust, 
                                        n_qtl_o = n_qtl_o, 
                                        n_otus = sum(n_clust != 0), 
                                        correlation = correlation, 
                                        effect_size = effect.size)
  beta_info <- attr(beta,"sim_params")
  otu_list <- list_c(beta_info$id_otu)
  
  ######
  #loop on generation to obtain microbiome
  ######
  ## ML estimate of founder pop compositions
  microbiome_gen <- apply(microbiome_filtered, 2, \(x) x/sum(x))
  ## shrinkage estimator: weighted average of ML composition and pop-level mean composition followed by clr transform
  microbiome_gen <- (mix.params[1] * microbiome_gen + mix.params[2] * matrix(rowMeans(microbiome_gen),nrow=nrow(microbiome_gen),ncol=ncol(microbiome_gen),byrow=F)) |> t() |> clr() |> t()
  # microbiome_gen <- microbiome_gen |> replace_zero() |> t() |> compositions::clr() |> t()
  #abundances
  taxa_scale <- microbiome_gen |> apply(1, sd)
  colnames(microbiome_gen) <- get.geno(population, gen = 1) %>% colnames()
  
  if(is.null(qtn_y)){
    Nqtl_y = 100
  }else{
    Nqtl_y = qtn_y
  }
  
  #####################
  ### founder phenotypes and parameters calibration
  #####################
  params_phenotypes <- calibrate_params_phenotypes(X0 = get.geno(population,gen = 1),
                                                   B0 = microbiome_gen, #CLR abundances ,
                                                   h2 = h2,
                                                   b2 = b2,
                                                   otu_list = otu_list,
                                                   Nqtl_y = Nqtl_y,
                                                   Notu_y = length(otu_list))
  
  phenotypes_founder <- compute_phenotypes(X = get.geno(population,gen = 1), 
                                           B = microbiome_gen, #CLR abundances 
                                           Nqtl_y = Nqtl_y, 
                                           Notu_y = length(otu_list), 
                                           otu_list = otu_list,
                                           qtl_list = params_phenotypes$qtl_list,
                                           beta_qtl = params_phenotypes$alpha,
                                           beta_otu = params_phenotypes$omega,
                                           se = params_phenotypes$se)
  
  
  #####################
  ### first elements output
  #####################
  metadata <- list(Beta_matrix = beta, 
                   QTN_y = params_phenotypes$qtl_list, 
                   G_coeff = params_phenotypes$alpha, 
                   B_coeff = params_phenotypes$omega)
  G0 <- list(microbiome = microbiome_gen |>  t() |> clrInv() |> t(), 
             genotypes = get.geno(population,gen = 1), 
             phenotypes = phenotypes_founder)
  list_output <- list(metadata = metadata, G0 = G0)
  
  
  #####################
  #Generation for loop
  ####################
  for(i in 1:n_gen){
    start_g <- proc.time()
    if(verbose){
      print(glue("Generation : {i}"))
    }
    #Warning : outside MoBPS functions, index of generation is i+1
    ######
    # Step 1 : get_current_genotype
    ######
    if(i==1){
      #renames microbiome matrix with individuals names
      population <- breeding.diploid(population,
                                     breeding.size = c(n_ind/2,n_ind/2),
                                     verbose = F)
    }else{
      population <- breeding.diploid(population,
                                     breeding.size = c(n_ind/2,n_ind/2), 
                                     selection.m.database = cbind(i,1,as.numeric(ID_selected$M_id)), 
                                     selection.f.database = cbind(i,2,as.numeric(ID_selected$F_id)),
                                     verbose = F)
    }
    
    ######
    # Step 2 : get_current_microbiome
    ######
    #Extract microbiomes of the mothers
    microbiome_gen <- microbiome_gen |>  t() |> clrInv() |> t()
    current_mother_microbiomes <- sapply(get.pedigree(population, gen=i+1)[,"mother"],function(x){
      microbiome_gen[,x]
    })
    
    mean_microbiome <- compute_mean_microbiome(microbiome_gen, 
                                               dir = dir,
                                               n_ind = n_ind,
                                               ao = ao,
                                               mix.params = mix.params.M)
    
    if(!is.null(env_gen)){
      if(env_gen[i]){
        microbiome_gen <- compute_current_microbiome(beta = beta,
                                                     current_genotypes = get.geno(population,gen = i+1),
                                                     mother_microbiomes = current_mother_microbiomes,
                                                     mean_microbiome = mean_microbiome,
                                                     noise = noise.microbiome, taxa_scale = taxa_scale, 
                                                     lambda = lambda,
                                                     dir = dir,
                                                     thetaX = thetaX) #not mandatory if we check dimension of mean_microbiome
      }else{
        microbiome_gen <- compute_current_microbiome(beta = beta,
                                                     current_genotypes = get.geno(population,gen = i+1),
                                                     mother_microbiomes = current_mother_microbiomes,
                                                     mean_microbiome = mean_microbiome,
                                                     noise = noise.microbiome, taxa_scale = taxa_scale, 
                                                     lambda = lambda,
                                                     dir = dir,
                                                     thetaX = NULL)
      }
    }else{
      microbiome_gen <- compute_current_microbiome(beta = beta,
                                                   current_genotypes = get.geno(population,gen = i+1),
                                                   mother_microbiomes = current_mother_microbiomes,
                                                   mean_microbiome = mean_microbiome,
                                                   noise = noise.microbiome, taxa_scale = taxa_scale, 
                                                   lambda = lambda,
                                                   dir = dir,
                                                   thetaX = NULL)
    }
    ######
    # Step 3 : get_current_phenotype
    ######
    phenotypes <- compute_phenotypes(X = get.geno(population,gen = i+1), 
                                     B = microbiome_gen, #CLR abundances 
                                     Nqtl_y = Nqtl_y, 
                                     Notu_y=length(otu_list), 
                                     otu_list = otu_list,
                                     qtl_list = params_phenotypes$qtl_list,
                                     beta_qtl = params_phenotypes$alpha,
                                     beta_otu = params_phenotypes$omega,
                                     se = params_phenotypes$se)
    
    
    ######
    # Step 4 : compute TBV to select individuals
    ######
    
    ID_selected <- select_individual(phenotypes = phenotypes,
                                     microbiomes = microbiome_gen |>  t() |> clrInv() |> t(),
                                     genotypes = get.geno(population,gen = 1+i),
                                     beta = beta,
                                     beta_otu = params_phenotypes$omega,
                                     selection = selection,
                                     size_selection_F = size_selection_F,
                                     size_selection_M = size_selection_M,
                                     selection_type = selection_type,
                                     w.param = w.param) 

    ###
    #update output
    ###
    list_output[[glue("G{i}")]] <- list(microbiome = microbiome_gen |>  t() |> clrInv() |> t(),
                                        genotypes = get.geno(population,gen = 1+i),
                                        phenotypes = phenotypes,
                                        pedigree = get.pedigree(population,gen = i+1),
                                        mean_microbiome = mean_microbiome,
                                        noise_microbiome = attr(microbiome_gen,"noise_microbiome"),
                                        ID_selected = c(glue("F_{ID_selected$F_id}"),glue("M_{ID_selected$M_id}")),
                                        omega_beta_g = as.vector(params_phenotypes$omega %*% (beta[rowSums(beta) != 0, ] %*% get.geno(population,gen = 1+i))))
    if(verbose){
      end_g <- proc.time() - start_g
      print(glue("Executed in {round(end_g[1] |> as.numeric(),3)} seconds"))
    }
  }
  return(list_output)
}

#' If selection based on diversity, need to go back to counts using multinomial sampling from abundances.
#'
#' @export
#' @inheritParams select_individual
richness_from_abundances_gen <- function(microbiome_matrix, n_loop=10, plot=T){
  microbiome_matrix[microbiome_matrix<0] <- 0
  for(i in 1:n_loop){
    microbiome_matrix <- apply(microbiome_matrix, 2, function(x){
      rmultinom(1,10000,as.vector(x))
    })
    tmp_physeq <- phyloseq(otu_table(microbiome_matrix,taxa_are_rows = T))
    if(i==1){
      richness <- estimate_richness(tmp_physeq,measures = c("Observed","Shannon","InvSimpson"))
    }else{
      richness <- richness + estimate_richness(tmp_physeq,measures = c("Observed","Shannon","InvSimpson"))
    }
  }
  return(richness/n_loop)
}

